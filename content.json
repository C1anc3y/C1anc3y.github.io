{"meta":{"title":"Kirk","subtitle":"debug.cool","description":"debug","author":"C1anc3y","url":"http://debug.cool","root":"/"},"pages":[{"title":"About","date":"2023-04-30T10:03:38.516Z","updated":"2023-04-30T10:03:38.516Z","comments":false,"path":"about/index.html","permalink":"http://debug.cool/about/index.html","excerpt":"","text":"Hi, I am Kirk! 👋 🔭 普普通通的代码搬砖工一名。 💬 欢迎一起玩耍、一起搞事~~~ ClanceyHuang#outlook.com"},{"title":"Links","date":"2021-05-07T07:30:39.996Z","updated":"2021-05-07T07:30:39.996Z","comments":true,"path":"links/index.html","permalink":"http://debug.cool/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-05-07T07:30:39.951Z","updated":"2021-05-07T07:30:39.951Z","comments":false,"path":"repository/index.html","permalink":"http://debug.cool/repository/index.html","excerpt":"","text":""},{"title":"Categories","date":"2021-05-07T07:30:39.997Z","updated":"2021-05-07T07:30:39.997Z","comments":false,"path":"categories/index.html","permalink":"http://debug.cool/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2021-05-07T07:30:39.986Z","updated":"2021-05-07T07:30:39.986Z","comments":false,"path":"tags/index.html","permalink":"http://debug.cool/tags/index.html","excerpt":"","text":""},{"title":"404 Not Found：该页无法显示","date":"2021-05-07T07:30:39.997Z","updated":"2021-05-07T07:30:39.996Z","comments":false,"path":"/404.html","permalink":"http://debug.cool/404.html","excerpt":"","text":""}],"posts":[{"title":"垃圾话碎碎念","slug":"lajihua","date":"2023-05-10T15:39:00.000Z","updated":"2023-05-10T16:28:10.485Z","comments":true,"path":"2023/05/10/lajihua/","link":"","permalink":"http://debug.cool/2023/05/10/lajihua/","excerpt":"新冠羊康之后还是留下了后遗症，从22年12月上海放开，圣诞节那会儿感染确诊，康复了之后一直咳嗽，咳嗽到现在23年5月了，还是没有好转。","text":"新冠羊康之后还是留下了后遗症，从22年12月上海放开，圣诞节那会儿感染确诊，康复了之后一直咳嗽，咳嗽到现在23年5月了，还是没有好转。 身体状态不好，五一假期还试图通过爬山的方式来唤醒身体机能，还是失败了，只能走走停停，衡山登顶用了将近7小时，其他人都是5小时左右。 对比新冠感染之前，爬黄山5小时、泰山3.5小时，怎么恢复身体状态现在是重中之重。 之前感染确诊那会儿，拍CT是没有异常的，2月中旬有天刷牙的时候咳血了（同时一直咳嗽没好），就去医院拍CT，发现肺部下叶有1mm多的实质结节。 回来按照医嘱服药，过敏体质引发了肠胃炎，停了一会药。一个月后还是咳嗽不断，再次去看，拍CT发现结节现在3mm-4mm了，一个月时间扩大了一倍多，这次还是开了会过敏的药（告知过医生对这类药过敏，但是医生坚持认为这药需要吃）。 4月份，同事推荐到一家知名的肺科医院看看，当时4.12，专攻结节方向的专家医生，她的预约排到了5.10，只能再等一个月。 今天刚从肺科医院看完，医生知道哪些药物过敏之后，开了其他的药，建议吃两周，如果还咳嗽，可能需要验验肺部其他情况或者穿刺结节了。 医嘱是需要多休息，可是打工人哪能有机会休息，最近几周加班程度都是连末班地铁都赶不上。 实在不行，就辞职休息一段时间，再找个合适的工作重新出发，毕竟身体要紧，人没了就啥都没了！ 本来之前因为公司不景气，半薪发放快两年了，导致房子快断供，低价出手了，现在身体再垮了可就真的GG了。","categories":[],"tags":[]},{"title":"《算法的力量》读后感","slug":"noteFuturePolitics","date":"2022-03-28T10:44:00.000Z","updated":"2022-11-15T14:35:07.869Z","comments":true,"path":"2022/03/28/noteFuturePolitics/","link":"","permalink":"http://debug.cool/2022/03/28/noteFuturePolitics/","excerpt":"《算法的力量》(原名:Future Politics)，看名字是讲的技术类，翻开是讲信息技术与政治的博弈，读完发现是一本对人类社会的预测之书。推荐给对新技术好奇，想看清未来的人。全书30w字，信息量巨大。花了一定篇幅解释一些政治和哲学概念，需要一点耐性来阅读。","text":"《算法的力量》(原名:Future Politics)，看名字是讲的技术类，翻开是讲信息技术与政治的博弈，读完发现是一本对人类社会的预测之书。推荐给对新技术好奇，想看清未来的人。全书30w字，信息量巨大。花了一定篇幅解释一些政治和哲学概念，需要一点耐性来阅读。 为什么对蚂蚁金服、滴滴打车重拳出击？看了这本书应该有更深的体会。 信息科技公司，正在拥有前所未有的财富。 当我们的一举一动越来越多的被转换成信息储存起来。去过的地方、点过的赞、24小时的心率，都会作为可分析的数据。 数据的聚拢会带来财富的聚拢。不仅仅是Facebook向目标用户投放广告，Google按竞价给予搜索结果排名这些收入。下一个增长点为人工智能，而人工智能的训练更需要海量的数据。 科技公司，甚至拥有了操控我们感知的权力。 过滤是一种无比强大的感知控制手段。科技公司能决定什么展现给你，什么过滤掉。 “我们感受和思考的方式決定了我们行动的方式。” 当代人的现状：感知被无形地控制在推荐算法织就的“信息茧房”中。 算法不懂政治，公司会死得很惨 网信办发出了关于算法治理检查的通知，进一步落实《数据安全法》、《个人信息保护法》范畴内的关于自动化决策以及“大数据杀熟”等消费者权益保护，反垄断等社会经济面热点问题的治理，这也和国家层面意识到的平台垄断和资本无序扩张密切相关。 在未来，算法将替代人工审核参与到生活中。但哪怕算法己经竭尽全力保持中立，结果仍然可能是不公正的。因为中立规则会重复和巩固世界上已经存在的不公正。如热点话题“男权女权”，一个神经网络算法在一个存储着300万个英语单词的数据库上学会了回答简单的类比问题。如“巴黎之于法国，正如东京之于？”该系统给出了正确回答。但当被问“男人之于计算机程序员，正如女人之于什么”时，系统的答复竟是家庭主妇，问“父亲之于医生，正如母亲之于什么”，系统的回答为护士。这个归类算法本质并不合理，可能由于打标签的工程师团队大多是男性，以及当前社会的分工定性，把事关正义的算法托付给一个绝大多数由男性组成的工程师团体其实也是不太正确的。 作者对自由、民主、公平、正义的论述和探索，饱含哲学探索与政治演变历程在面对未来数字化时代所遭遇到的挑战，算法在其中起到的作用“如果说毛主席所说的枪杆子里出政权的话，不免可以延伸为算法里出政权”，而私营企业如果控制的话不免出现跨越物理边界的虚拟国家，从这个角度而言，扎克伯格的libra从轰轰烈烈到悄无声息可见其天真梦想的幻灭，同样对于去中心化的区块链以及非政府的数字货币，命运多桀是一种必然，可以送上一句悼词，too young too simple，不懂政治。 数字化时代，首当其冲的数据生产要素提上日程，显然数据要素应用所依赖的算法一定程度上决定了数据的价值，仰或进一步而言，会影响到人类社会的个体和群体生活，那么无论是监管和立法都需要在路上，而作为技术从业者，我关注的是如何技术上实现对算法的治理，也就是说治理算法的算法。 如何监管是个复杂的命题，避免集中，透明化专业审查显然是能想到的答案之二，具体仍需边走边看，不过这本书真的可以列为算法影响力的必读之书了。","categories":[{"name":"笔记","slug":"笔记","permalink":"http://debug.cool/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://debug.cool/tags/%E7%AE%97%E6%B3%95/"},{"name":"读后感","slug":"读后感","permalink":"http://debug.cool/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"},{"name":"Future Politics","slug":"Future-Politics","permalink":"http://debug.cool/tags/Future-Politics/"}]},{"title":"威胁情报-观测问题","slug":"tiObservationProblem","date":"2021-08-08T07:44:00.000Z","updated":"2022-11-15T14:50:59.226Z","comments":true,"path":"2021/08/08/tiObservationProblem/","link":"","permalink":"http://debug.cool/2021/08/08/tiObservationProblem/","excerpt":"听到的一切都是一个观点，不是事实。看到的一切都是一个视角，不是真相。","text":"听到的一切都是一个观点，不是事实。看到的一切都是一个视角，不是真相。 引子 南城的人听北城的朋友说，雨从北边来，南城的朋友抬头感受着来自北面的清风，考虑着，出门要不要带把伞呢？ 预测不靠谱 威胁情报本身没有预测的意义在其中，它只强调观测和专家式的推理，至少我是这么理解的。 而态势感知才是在进行着整个人类都难以颠覆的一个事实 —— 尝试去预测。 为什么说预测是难以颠覆的事实？因为一直到前几天我才知道，其实气象台对暴雨的预测准确率只有20%。 天气预报作为一项全世界人类最大的逆天预测活动，在持续了一个多世纪之后就是这种结果。说实话，一时间我还真有点接受不了，这个事实都快逼得我去信上帝了。 而现在，互联网普及到发展了不过二十几年，人类对庞大数据的积累和认识也只有几年的情况下，他们会说：因为我有庞大的数据，所以我可以预测未来。呵了个呵！！ 观测只是基础 显而易见的是，观测这个动词本身就意味着看到而不是想象到。 看到就意味着某个视角的事实 —— 当然，你要是较真跟我讲《黑客帝国》那一套我也肯定说不过你。 而观测却只是基础，最终我们想要的一定是，先有基于事实的观测，再有根据观测进行的推理。 就好象IDS里看到了扫描，就意味着可能有入侵行为或病毒等事件正在发生(虽然更多情况下是因为误报)。 所以，此处应有专家出现。 多数观测并不是通过简单的推理和看似事实的事件组合在一起就能形成结论的 —— 好像IDS误报的扫描一样。 我查了一下关于天气局部预测的相关知识，虽然我完全没看明白，但我也知道了一个基本结论： 北城下雨且有北风向南吹，但仍然有可能会出现南城整天滴雨未降的情况。 所以引子里看似必然的结果，其实在气象专家眼里就未必是那么确定了。 因此，观测是专家系统的输入：观测结果 （输入）----&gt; 专家系统（专家）----&gt; 推理结果（输出）。 推理结果是否可作为情报，应该是和专家有相当大关系的，所以这些年来，舆论里被调戏最多的也是&quot;砖家&quot;和&quot;叫兽们&quot;。 另一方面，正是因为专家这层神秘的过程，所以简单的观测+专家的输出看起来似乎变得神秘，神秘的好像是在预测未来一样。 但说的更直白一些，无非就是一些普通人没有注意到的事实和一些普通人不具备的知识组合在一起的结果罢了。 现在的观测有什么不同 既然是有扫描就意味着这是入侵前奏这么简单的原理，那么，重新捡起一套IDS，似乎观测数据源的问题就解决了。 但实际上并非如此，毕竟，距离最早一批IDS至少已经过去17年了(SNORT诞生于1998年)，很多形态和思路到现在已经不再适用。 现在形势下，观测的基本原则应是不以关注目标为核心点的事件发现、分析和处理能力，这种情况下需要考虑更多的维度。 而现形势下，最需要关注的就是观测的广度，因为现在攻击事件的内在关联已经变得极其复杂。 有一些攻击是因为目标系统防御严格而使用曲线救国的方式(例如Stuxnet)，而有一些则是攻击覆盖面过于宽广而被殃及池鱼(现在很多日志里能看到失败或是成功的一次性payload)。 当然，有广度就需要有深度，深度主要是自我认知的深度，说白了就是知道自己有什么东西、东西在哪、长什么样、变化情况如何等等。 历史数据是否还重要 现在普遍的来说，安全圈子里无论是谈到推测、预测或是感知，都会想象基于历史数据而进行分析，从而形成对未来的预测或感知能力。 所以，现在就沦为了历史数据积累，积累到要吐的时候才发现，其实并没有什么卵用，于是只好画几张图飞来飞去来展现自己积累的这些不是垃圾。 那么，历史数据是否真的重要？ 在以前的观点里我已经阐述过。 对历史的分析不是意味着历史数据自身的有效性，而是因为人性从未改变。 任何历史数据都是人产生的，如果将未来即将产生的事件也视为一种数据的话，那这份数据一定还是由于人所产生。 那么人所产生的未来(数据)一定能在历史(数据)中得以挖掘和展现 —— 但问题就在于，这只是臆想而已。 整个过程其实忽略了很大的问题就是：数据是结果，人性才是产生数据的驱动力。 过分的关注结果而没有考虑结果到驱动力的逆推过程，这样的历史数据积累，除了最后拼存储单位以外，也难以找到更多价值。 观测有什么好处 首先需要承认的就是，在自打安全风险的概念出现之初，我们所在讨论的就是&quot;降低风险&quot;而不是&quot;消除风险&quot;。 威胁情报为&quot;观测&quot;这件事赋予的意义其实也是类似的，也就是说，牺牲局部保全整体其实是一个不错的办法。 利用局部地区观测到的问题将其通过专家系统放大转换到其他具有某种相关性的系统范围之内，然后进行预警、防御等决策的推进。 而如果运气好的话，很多时候这些被牺牲掉的局部甚至可能与你无关 —— 也许你看见隔壁老王家被盗了，赶紧换了跟他家不一样的锁芯。 另外一方面，就是评价结果相对更为鲜明。 因为观测得到的一个初步结果就是已发生在局部的事实，而对于这样一个事实是否会影响到其他区域，其评价指标是比较容易设计和衡量的。 对于纯粹消耗资金的安全事业来说，这是一个伟大的创举。 其他 其他什么的，我也想不到了，就这样吧。","categories":[{"name":"安全","slug":"安全","permalink":"http://debug.cool/categories/%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"网络安全","slug":"网络安全","permalink":"http://debug.cool/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"碎碎念","slug":"碎碎念","permalink":"http://debug.cool/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}]},{"title":"Windows10下WSL开发环境搭建","slug":"tipsWSL","date":"2021-01-20T14:44:00.000Z","updated":"2022-12-19T14:53:20.245Z","comments":true,"path":"2021/01/20/tipsWSL/","link":"","permalink":"http://debug.cool/2021/01/20/tipsWSL/","excerpt":"工作环境的一架台式机是Windows10系统，Windows系统对开发者来说并不是很友好（.net及Windows内核开发者除外，比如一些扩展包，例如PHP的swoole，在Windows上现在没有直接安装的解决方案）。","text":"工作环境的一架台式机是Windows10系统，Windows系统对开发者来说并不是很友好（.net及Windows内核开发者除外，比如一些扩展包，例如PHP的swoole，在Windows上现在没有直接安装的解决方案）。 刚开始一段时间(WSL没有出来那会，也不想用虚拟机和Docker)把台式机改成Linux系统，但是呢，各种办公软件在Linux平台就很糟心了，比如微信、QQ 这些软件，在Linux没有官方版本，通过黑科技进行移植的版本会出现各种故障，比如发送文档都得做磁盘空间共享，简直让人崩溃。 如果是纯粹只负责写代码的工作场景倒无所谓了，但是需要和客户、同事进行沟通，涉及到视频、音频、文件传输，简直炸毛。。。 背景 某天装备升级强化了下，内存有16G，试着安装了Windows的WSL，这是微软自研的架构，为了兼容Linux内核。简单来讲就是Windows系统内置了一套Linux内核，直接做了系统间的映射。 准备 材料 Windows10 wsl Ubuntu18.appx WSL 环境初始化 打开Windows自带的power shell终端，执行Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux命令，就在Windows上安装好了wsl环境。 接着下载一份Ubuntu18.04镜像，同样是在power shell终端执行命令Invoke-WebRequest -Uri https://aka.ms/wsl-ubuntu-1804 -OutFile Ubuntu.appx -UseBasicParsing，当前目录路径下就会出现一个Ubuntu的appx软件，点击安装即可。 Ubuntu 配置 点击安装Ubuntu.appx后，系统会弹出一个黑色窗口，提示你输入unix系统的用户名及密码，正常配置即可。 修改镜像源 我们需要把Linux系统的软件镜像地址改成国内的镜像地址，否则安装软件包会卡到你怀疑人生，我们先到网上搜索一下Ubuntu18国内镜像源（这里选用了阿里的镜像源），源链接如下： 1234567891011# alibaba source listdeb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse 得到需要的源链接后，再到Ubuntu系统里更改源文件即可，命令操作如下： 1234567# 先备份原文件sudo cp /etc/apt/source.list /etc/apt/source.list-back# 再更改原文件sudo vim /etc/apt/source.list# 将上面的源链接拷贝进来，再保存退出# 更新系统的源包管理sudo apt-get update &amp;&amp; sudo apt-get upgrade -y 这样，我们就配置好了国内镜像源。 部署 nginx web开发，一般web代理服务器选择apache或者nginx，这里讲nginx的部署，相应的操作命令如下： 123456# 安装nginx，等待一段时间即可。sudo apt-get install nginx# 创建我们的vhost文件夹mkdir ~/vhost# 更改nginx配置sudo vim /etc/nginx/nginx.conf 在 include /etc/nginx/site-avaliable 下引入我们的 vhost 文件夹： 1include /home/kirk/vhost/*.conf; 本地 hosts 配置下开发域名 123sudo vim /etc/hosts# 增加一条指向记录127.0.0.1 api.kirk.com 编写 vhost 文件,如 vim ~/vhost/Kirk.conf 12345678910111213141516171819202122232425262728# API 解析server &#123; listen 80; server_name api.kirk.com; # 这里的项目地址是宿主机的项目地址，因为在Windows内置的Linux系统中，读取宿主机Windows文件的方式是使用挂载的模式， # 把Windows系统盘当成挂在盘进行处理，例如/mnt/d表示Windows的D盘，我们在D盘github/kirk文件夹下写了一个php文件，里面打印一个phpinfo(); root &quot;/mnt/d/github/kirk&quot;; location / &#123; index index.php index.html error/index.html; if (!-e $request_filename) &#123; rewrite ^(.*)$ /index.php?s=/$1 last; break; &#125; autoindex off; &#125; location ~ \\.php(.*)$ &#123; # 记住这里fastcgi监听的是9004端口，后面配置php-fpm的时候会用到，因为fastcgi要和php-fpm端口保持统一 fastcgi_pass 127.0.0.1:9004; fastcgi_index index.php; fastcgi_split_path_info ^((?U).+\\.php)(/?.+)$; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; fastcgi_param PATH_INFO $fastcgi_path_info; fastcgi_param PATH_TRANSLATED $document_root$fastcgi_path_info; include fastcgi_params; &#125;&#125; 保存完conf文件后，再执行sudo service nginx reload进行重载nginx的配置。 安装 php 这里选用了php74版本，具体命令如下： 12345678# 先安装一个软件中心组件sudo apt-get install software-properties-common# 再添加一个php的第三方源（因为官方源的php版本不大适用，一个是版本少，另一个是扩展包比较少）sudo add-apt-repository ppa:ondrej/php# 再刷新一下包管理器sudo apt-get update# 安装对应版本的php及扩展包，扩展包自行按需添加sudo apt-get install php7.4 php7.4-fpm php7.4-mysql php7.4-gd php7.4-mbstring php7.4-redis 处理php-fpm，操作如下： 123456# 修改php-fpm监听的端口，与nginx的fastcgi保持一致sudo vim /etc/php/74/fpm/pool.d/www.conf# 找到listen = /run/php/php7.4-fpm.sock ,并改成下面的监听配置listen = 127.0.0.1:9004# 修改保存成功后，重启php-fpm即可sudo service php7.4-fpm restart 这样打开Windows的浏览器，访问我们刚刚配置的站点http://api.kirk.com，出现php版本信息即表示配置成功。 然后，看了下性能损耗，Windows基本的应用加上wsl共消耗3G内存，还是比集成软件PHPstudy节省了一丢丢内存，最主要的是以前Windows不能安装的扩展现在可以随意安装了~ 再试着打开微信、企业微信、开发软件 IDE，好家伙，直接达到8G内存，平时半天没有回复你们信息不是故意不回，是电脑卡死了在等待。 安装 python 环境 单单只有一个php怎么玩数据呢，需要部署下python，Ubuntu自带了python3，但是我们需要按照不同项目做环境隔离，所以需要特殊处理下隔离软件的配置： 1234567891011121314151617181920212223242526# 先看看Ubuntu有没有自带python3，执行如下命令python3# 如果进入了python3操作界面，表示系统已安装，反之需要我们自己安装.# 安装命令sudo apt-get install python3# 验证是否安装pip 包管理器pip3 -V# 如果没有出现pip3的版本信息，代表系统没有安装，需要我们手动安装sudo apt-get install pip3# 安装好了之后，开始安装python虚拟环境sudo pip3 install virtualenvsudo pip3 install virtualenvwrapper# 配置包引导sudo vim ~/.bashrc# 在最后加上这几条命令，分别表示1.虚拟环境的工作目录。2.虚拟包用python3进行驱动。3.加载虚拟包执行脚本。export WORKON_HOME=$HOME/.virtualenvsexport VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3source ~/.local/bin/virtualenvwrapper.sh# 保存退出后source ~/.bashrc# 这样python虚拟环境管理包就配置好了，我们可以用如下命令创建对应的虚拟环境mkvirtualenv -p python3 Kirk# 退出python虚拟环境deactive# 删除对应虚拟环境rmvirtualenv Kirk 这样通过virtualenvwrapper进行管理python的虚拟环境，从而实现不同的项目使用不同的python包管理。 其他的环境配置会陆续更新，to be continue…","categories":[{"name":"笔记","slug":"笔记","permalink":"http://debug.cool/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://debug.cool/tags/Python/"},{"name":"WSL","slug":"WSL","permalink":"http://debug.cool/tags/WSL/"},{"name":"Windows10","slug":"Windows10","permalink":"http://debug.cool/tags/Windows10/"},{"name":"Nginx","slug":"Nginx","permalink":"http://debug.cool/tags/Nginx/"},{"name":"PHP","slug":"PHP","permalink":"http://debug.cool/tags/PHP/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://debug.cool/tags/Ubuntu/"}]},{"title":"DiyExpress - 自定义表达式计算引擎","slug":"devDiyExpress","date":"2020-12-08T16:00:00.000Z","updated":"2023-02-25T03:57:55.552Z","comments":true,"path":"2020/12/09/devDiyExpress/","link":"","permalink":"http://debug.cool/2020/12/09/devDiyExpress/","excerpt":"我们在数据分析的业务上，经常会有一些比较脑洞大开却又很实用的需求。 比如有个场景，当我们将数据分析的”自主权“交给用户。","text":"我们在数据分析的业务上，经常会有一些比较脑洞大开却又很实用的需求。 比如有个场景，当我们将数据分析的”自主权“交给用户。 由用户来决定自己需要计算分析什么维度的数据，这个需求确实是一个痛点，能解决这个需求，不就是为用户创造了价值么。 因此，花了点时间写了一套自定义表达式计算引擎。 已知用户是有一定Excel公式基础的，需要提供一个交互界面让他输入他定义的类似Excel公式的一段简单公式，其中的各个参数是自定义表单中各个字段所填充的数据。如下： 1&#123;&#123;销售返现&#125;&#125;=if ( &#123;&#123;数量&#125;&#125; &gt;= 100 AND (&#123;&#123;产品类型&#125;&#125; == &#x27;产品A&#x27; OR &#123;&#123;产品类型&#125;&#125; == &#x27;产品B&#x27;), &#123;&#123;成单金额&#125;&#125; * 0.7, &#123;&#123;成单金额&#125;&#125;*0.5) + 100 双花括号里面的是指定的字段（用来代表该字段的取值 data），单引号或者双引号是指定的取值。 我们的目标是程序根据用户定义的公式计算对应的数据，那么核心点在于如何识别用户定义的公式。 依旧是被“自定义”给坑了，需要识别用户定义的公式只能上一个词法分析器了，根据大三学的编译原理，徒手撸个状态机。。 考虑到能用脚本语言就用脚本语言，技术选型用的PHP,源码放在 github 上，DiyExpress。 贮备知识点 AST 节点树 AST (Abstract Syntax Tree(抽象语法树)) 是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构。它由一堆节点（Node）组成，每个节点都表示源代码中的一种结构。不同结构用类型来区分，常见的类型有： Identifier(标识符)，BinaryExpression(二元表达式)，VariableDeclaration(变量定义)，FunctionDeclaration(函数定义)等。 AST 是编译器看的。编译器会将源码转化成 AST。如下源码: 123456var a = 42;var b = 5;function addA(d) &#123; return a + d;&#125;var c = addA(2) + b; 会换转化成这样的 AST: AST 的使用场景？ TypeScript、babel、webpack、vue-cli等都是依赖AST进行开发的。 通过AST，可以将代码转化后，再输出。比如： 代码压缩。删除没用的空格，未使用的语句，变量名替换等。 代码高亮。 将 ES6 代码转换成 ES5 代码。 给 CSS 中的某些属性加浏览器前缀-webkit-。 将 CSS 中的px转化成rem。 生成代码。最近用了ANT DESIGN PRO。 ANT DESIGN PRO 中的 umi 可以在生成页面的代码和路由时，修改路由配置的js。umi 这种方式，用户体验很好。因此，我准备用这种方式来改造我之前做的代码生成工具。修改路由配置需要通过 AST 来转换代码。 需要学习 AST 的哪些知识？ 了解 AST 常见节点的结构 了解 AST 常见节点的结构推荐通读下AST node 规范。 源码解析 将源码转化为AST。该步骤分为词法分析（Lexical Analysis）和 语法分析（Syntactic Analysis）。 解析 JavaScript 可以用@babel/parser(以前叫 Babylon)。 转换 在遍历AST时，对指定的AST节点做新增，修改或删除操作。 转换可以用@babel/traverse。 创建和验证节点可以用@babel/types。创建AST节点代码示例见这里。 生成目标代码 将上一步转换过的AST，转化为目标代码，并生成源码映射（source maps）。 生成目标代码可以用@babel/generator To be continue…","categories":[{"name":"研发","slug":"研发","permalink":"http://debug.cool/categories/%E7%A0%94%E5%8F%91/"}],"tags":[{"name":"研发","slug":"研发","permalink":"http://debug.cool/tags/%E7%A0%94%E5%8F%91/"},{"name":"自定义表达式","slug":"自定义表达式","permalink":"http://debug.cool/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"状态机","slug":"状态机","permalink":"http://debug.cool/tags/%E7%8A%B6%E6%80%81%E6%9C%BA/"},{"name":"自然语言解析","slug":"自然语言解析","permalink":"http://debug.cool/tags/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E8%A7%A3%E6%9E%90/"}]},{"title":"Window10下双系统grub修复","slug":"tipsDoubleSystem","date":"2020-03-15T15:10:00.000Z","updated":"2023-01-15T08:49:45.148Z","comments":true,"path":"2020/03/15/tipsDoubleSystem/","link":"","permalink":"http://debug.cool/2020/03/15/tipsDoubleSystem/","excerpt":"起因是我的笔记本window10在某次更新升级时，将之前设置好的双系统引导破坏了，导致进入Linux系统时提示Unknown filesystem。","text":"起因是我的笔记本window10在某次更新升级时，将之前设置好的双系统引导破坏了，导致进入Linux系统时提示Unknown filesystem。 首先能确定的是Linux的引导读取出了问题，才进入到了grub rescue模式。如果记得自己的Linux引导安装在哪个区块可以直接重新读取引导（这个得看你安装双系统的时候，把Linux的引导装在哪个分区），如果不记得，就执行下面的命令输出gpt分区 1ls 这样会显示出你所有的分区，再一个一个试试下面的命令（我的引导安装在gpt7区块上） 1ls (hd0,gpt7)\\boot\\grub 其他不是引导所在的分区都是提示error: unknown filesystem。找到了所在的分区会提示该目录下的文件目录。 假定你们也是(hd0,gpt7)分区，依次执行下面的命令： 1234set root=(hd0,gpt7),set prefix=(hd0,gpt7)/boot/grubinsmod normal,normal 执行完毕会进入Linux启动的图形界面。 进入Linux系统后，打开终端执行以下命令重新安装grub引导： 12sudo update-grubsudo grub-install /dev/sda 再重启，就能恢复到正常Linux的启动引导了。","categories":[{"name":"笔记","slug":"笔记","permalink":"http://debug.cool/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://debug.cool/tags/%E7%AC%94%E8%AE%B0/"},{"name":"维修","slug":"维修","permalink":"http://debug.cool/tags/%E7%BB%B4%E4%BF%AE/"}]},{"title":"自定义表单设计及实现方案","slug":"devDiyForm","date":"2020-02-03T06:30:00.000Z","updated":"2022-11-15T14:29:40.342Z","comments":true,"path":"2020/02/03/devDiyForm/","link":"","permalink":"http://debug.cool/2020/02/03/devDiyForm/","excerpt":"如何设计一款高度自定义的表单系统？ 自定义意味着表单数量不确定，每个表单字段数量不确定，每个字段类型不确定，存储量不确定，等等一切都是未知的。","text":"如何设计一款高度自定义的表单系统？ 自定义意味着表单数量不确定，每个表单字段数量不确定，每个字段类型不确定，存储量不确定，等等一切都是未知的。 以及之后如何建立索引，如何搜索定位指定的数据？这些问题都将在下面的方案中进行解答。 背景 为了实现某个比较脑洞大开的需求，建立自定义表单，而且，还限定了前置条件—技术选型不许复杂，数据存储只能基于mysql, So… 所谓的“自定义”（表设计） 我们会定义这么几张表，用来实现自定义模板的大致框架。 12345diy_field_pool 字段池（我们定义好的字段类型）diy_form 表单表（记录用户自定义的表单）diy_form_field 表单字段表（记录某张表单中有哪些字段）diy_form_entity 表单实例表（记录某张表单中的某条数据实例）diy_form_data 表单数据表（记录某张表单在某条实例下，哪些字段对应的数据） 系统初始化字段池 我们提供一批预定义的字段类型，初始化数据到diy_field_pool表中，用户也能自己定义自己的字段池。 用户创建自定义表单 用户通过选用字段池（diy_field_pool表）中提供的字段，创建一张自定义表单，表单的属性信息记录在diy_form表中，表单包含的字段（从字段池中选好的字段）记录在diy_form_field表中。这样用户就创建了一张自定义表单。 用户填写表单 用户使用创建好的表单填写数据，每新增一条数据，在diy_form_entity表就会新增一条记录，该表单中有几个field，就会同时在diy_form_data表中新增几条 data 数据。数据结构关系如下图所示： 123456789101112131415diy_form ------ diy_enity| ||---diy_field |---diy_data| ||---diy_field |---diy_data| ||---diy_field |---diy_data| ||---diy_field |---diy_data| ||---diy_field |---diy_data| ||---diy_field |---diy_data| ||... 如何进行数据搜索 数据存储结构中，最终保存数据的地方其实是data表，但是，data表的辅助字段有form表id，field表id，entity表id，只有一个content字段是记录真实信息的，那么，如何搭建索引体系呢？ 采用 Sphinx 构建Sphinx的sql语句时，将data表的id作为文档id。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172# 公共的自定义模板的数据源source diyCommonSource&#123; type = mysql sql_db = diy sql_host = 127.0.0.1 sql_port = 3306 sql_user = root sql_pass = root sql_query_pre = SET NAMES utf8 sql_query = \\ select \\ dfd.id, \\ dfd.entity_id,dfd.content,dfd.createat,dfd.updateat, \\ dff.id as field_id,dff.sys_id,dff.field, \\ df.id as form_id \\ from diy_form_data as dfd \\ inner join diy_form_field as dff on dff.form_id=dfd.form_id and dff.is_delete=0 \\ inner join diy_form as df on df.id=dff.form_id and df.is_delete=0 \\ where dfd.is_delete=0&#125;# 公共的自定义模板的索引index diyCommonIndex&#123; source = diyCommonSource path = /var/local/diy/sphinx/data/diyCommonIndex docinfo = extern #charset_type = zh_cn.utf-8 charset_type = utf-8 min_word_len = 1 ngram_len = 1 ngram_chars = U+3000..U+2FA1F&#125;# 范围：新闻模板（假定form_type为1）source news:diyCommonSource&#123; sql_query = \\ select \\ dfd.id, \\ dfd.entity_id,dfd.content,dfd.createat,dfd.updateat, \\ dff.id as field_id,dff.sys_id,dff.field, \\ df.id as form_id \\ from pre_diy_form_data as dfd \\ inner join pre_diy_form_field as dff \\ and dff.form_id=dfd.form_id \\ and dff.sys_id&gt;0 and dff.is_delete=0 \\ inner join pre_diy_form as df \\ and df.id=dff.form_id \\ and df.is_delete=0 \\ and df.form_type=1 \\ where dfd.is_delete=0 # 使用sql_attr设置的字段(搜索条件)，只能作为属性，使用SphinxClient::SetFilter()进行过滤； # 未被设置的字段，自动作为全文检索的字段，使用SphinxClient::Query(&quot;搜索字符串&quot;)进行全文搜索 # sql_query第一列id需为整数，且被系统使用，无需再设置sql_attr_uint sql_attr_uint = form_id sql_attr_uint = field_id sql_attr_uint = field sql_attr_uint = entity_id sql_attr_timestamp = createat sql_attr_timestamp = updateat&#125;# 构造商品模板的数据索引index news:diyCommonIndex&#123; source = news path = /var/local/diy/sphinx/data/news&#125; 其中，如果需要指定查找某些字段的数据，那么，以上面的数据源再重新定义数据源，sql 语句进一步指定 field 表的某个标志字段即可。","categories":[{"name":"研发","slug":"研发","permalink":"http://debug.cool/categories/%E7%A0%94%E5%8F%91/"}],"tags":[{"name":"研发","slug":"研发","permalink":"http://debug.cool/tags/%E7%A0%94%E5%8F%91/"},{"name":"自定义模版","slug":"自定义模版","permalink":"http://debug.cool/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E7%89%88/"},{"name":"数据存储","slug":"数据存储","permalink":"http://debug.cool/tags/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"},{"name":"数仓","slug":"数仓","permalink":"http://debug.cool/tags/%E6%95%B0%E4%BB%93/"},{"name":"数据湖","slug":"数据湖","permalink":"http://debug.cool/tags/%E6%95%B0%E6%8D%AE%E6%B9%96/"}]},{"title":"验证码识别","slug":"devCrack","date":"2019-05-10T07:44:00.000Z","updated":"2023-02-25T03:57:48.654Z","comments":true,"path":"2019/05/10/devCrack/","link":"","permalink":"http://debug.cool/2019/05/10/devCrack/","excerpt":"通过训练卷积模型，让程序自动识别验证码。","text":"通过训练卷积模型，让程序自动识别验证码。 背景 运营人员审核某些用户提交的资质证书的时候，需要到规定的公示网站上去查询证书，大致操作是这些： 到公示网站填写对应信息（证书编号等） 填写验证码（每次查询都会有校验码或者短信验证等等） 查看查询结果并比对证书 这一套流程下来，无疑是加大了审核员的工作量，而且每天审核的不止一张证书。一个比较迫切的需求就诞生了，根据不同证书种类，分别去自动获取公示网站上该证书的信。 假定以教师资质证书为例，该公示站点查询信息时，需要输入证书编号，图片验证码，即可返回该证书所对应的信息，运营人员比对用户上传的证书和站点公示的证书即可。 方案一 现在方案一是在我们自己的审核后台，将所有的数据（查询时需要的证书编号、姓名等等）都提取出来，封装成一个 post 请求数据，并将公示网站的验证码获取过来，在审核后台只留一个验证码的输入框给审核人员，输入正确的验证码，追加到 post 请求中，即可进行查询（该过程中会话交互验证的破解思路请自行摸索），将返回的数据结果进行切割处理，以比较好的交互方式呈现给运营人员。运营人员剩下的工作只要 check 一下信息即可。 ps：方案一的背后其实还进行了另一步操作，只要查询成功，就将这张验证码图片保存到本地服务器，运营人员输入的验证码作为图片名（这一步是关键，因为需要大量的训练样本进行模型训练，为方案二做铺垫）。 方案二 等一段时间后，将方案一保存下来的这批图片数据作为训练样本，去训练模型，也就是方案二，当模型的准确率达到了 0.9 以上，就可以实际拿过来使用了。（可能会说为什么不自动生成相似的验证码来进行训练，这也是一个思路，但准确率没有拿目标样本作为训练样本来的高，因为我们是不知道对方验证码的生成规则的，只能仿出一个大概相似的验证码。） 方案二部署上线的时候，只要用户提交了相关的证书信息，我们的系统就自动去公示网站上查询数据并将结果保存到数据库，这样运营人员只要在审核后台核对查询结果即可，也不用再输入验证码了。 为了更好的兼容，之前方案一预留的手动填写验证码功能也不会删减掉，防止出现系统无法自动识别验证码、获取不到查询数据的情况。这样如果系统自动查询到了数据运营人员就能直接审核，没有查询到数据，运营人员还能手动查一遍进行确认，同时还收集了验证码的训练样本。 总结 方案二是在方案一使用一段时间后才能进行的，因为我们需要大量的训练样本，如果特意通过人工去获取数据（验证码图片）并打标签（每张图片所代表的验证码），无疑是会浪费很大的人力资源。 这样在方案一阶段，审核人员还是进行常规的审核操作，就顺便收集了对应的训练数据。等到执行案案二，就将审核员彻底解放出来，在需求（审核功能、上线时间）、成本（时间、人力）、技术实现（样本获取）上目前应该是最优解了。 补充 其实同时还是做了高仿目标站点的验证码，争取做到大致相同。然后tensorflow训练后的识别率达到0.9左右估计就差不多了。 源码","categories":[{"name":"研发","slug":"研发","permalink":"http://debug.cool/categories/%E7%A0%94%E5%8F%91/"}],"tags":[{"name":"研发","slug":"研发","permalink":"http://debug.cool/tags/%E7%A0%94%E5%8F%91/"},{"name":"破解","slug":"破解","permalink":"http://debug.cool/tags/%E7%A0%B4%E8%A7%A3/"}]},{"title":"Python封装Kafka客户端","slug":"devKafka","date":"2019-04-20T12:44:00.000Z","updated":"2022-11-15T14:30:44.519Z","comments":true,"path":"2019/04/20/devKafka/","link":"","permalink":"http://debug.cool/2019/04/20/devKafka/","excerpt":"业务上处理Kafka主要就扣着“生产者”和“消费者”这个点就行，下面讲的是在Python中封装一个比较好用的Kafka客户端。","text":"业务上处理Kafka主要就扣着“生产者”和“消费者”这个点就行，下面讲的是在Python中封装一个比较好用的Kafka客户端。 no bb, show code.直接上代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#!/usr/bin/env python# encoding: utf-8import sysfrom pykafka import KafkaClientreload(sys)sys.setdefaultencoding(&#x27;utf8&#x27;)class KafkaTaskException(Exception): &quot;&quot;&quot; 在这里自定义KafkaTask类的异常 &quot;&quot;&quot; passclass ParameterError(KafkaTaskException): &quot;&quot;&quot; 参数异常错误 _ParameterError_Key: 当 key 类型错误的时的抛错. _ParameterError_Topic: 当 topic 类型错误的时的抛错. _ParameterError_Consumer: 当初始化init_consumer 使用了错误的参数时抛错. &quot;&quot;&quot; _ParameterError_Key = &quot;ParameterError- type(s) for &#x27;Key&#x27;: must be bytes&quot; _ParameterError_Topic = &quot;ParameterError- type(s) for &#x27;topic&#x27;: must be bytes&quot; _ParameterError_pykafka_Consumer = &quot;ParameterError- type(s) for &#x27;topic&#x27;: must be bytes; &quot; \\ &quot;type(s) for &#x27;group_id&#x27;: must be str; &#x27;offset_type&#x27; &quot; \\ &quot;must be &#x27;LATEST&#x27; or &#x27;EARLIEST&#x27;&quot; _ParameterError_kafka_Consumer = &quot;ParameterError- type(s) for &#x27;topic&#x27;: must be str; &quot; \\ &quot;type(s) for &#x27;group_id&#x27;: must be str; &#x27;offset_type&#x27; &quot; \\ &quot;must be &#x27;LATEST&#x27; or &#x27;EARLIEST&#x27;&quot; passclass KafkaTask(object): &quot;&quot;&quot; 封装一个pykafka的客户端方法 &quot;&quot;&quot; def __init__(self, server): &quot;&quot;&quot; :param server: str类型 &quot;&quot;&quot; self.server = server self.client = KafkaClient(hosts=server) def init_producer(self, topic): &quot;&quot;&quot; 初始化Kafka生产者 :param topic:Type --&gt; bytes `Produce msg what topic You want`. :raises ParameterError: 当topic不是bytes类型时抛错. :return: &quot;&quot;&quot; if not isinstance(topic, bytes): raise ParameterError(ParameterError._ParameterError_Topic) topic = self.client.topics[topic] self.producer = topic.get_producer(sync=True) def init_consumer_pykafka(self, topic, group_id, offset_type): &quot;&quot;&quot; Init Kafka Consumer by pykafka :param topic:Type --&gt; bytes `Consumer msg what topic You want`. :param group_id: Type --&gt; str `Consumer msg what group_id You want,You can receive duplicate data using different group_id in same topic`. :param offset_type:Type --&gt; str `LATEST can receive the latest data,EARLIEST can receive earliest data in topic` :raises ParameterError: When use error Parameter to init init_consumer. :return: &quot;&quot;&quot; if not isinstance(topic, bytes) or not isinstance(group_id, str) or not isinstance(offset_type, str) or offset_type not in [&quot;LATEST&quot;, &quot;EARLIEST&quot;]: raise ParameterError(ParameterError._ParameterError_pykafka_Consumer) from pykafka.simpleconsumer import OffsetType _OffsetType = &#123;&quot;LATEST&quot;: OffsetType.LATEST, &quot;EARLIEST&quot;: OffsetType.EARLIEST&#125; topic = self.client.topics[topic] self.consumer = topic.get_simple_consumer(auto_commit_enable=True, auto_commit_interval_ms=1, consumer_id=group_id, auto_offset_reset=_OffsetType[offset_type], reset_offset_on_start=True) def init_consumer_kafka(self, topic, group_id, offset_type): &quot;&quot;&quot; Init Kafka Consumer by kafka-python :param topic: Type --&gt; str `Consumer msg what topic You want`. :param group_id: Type --&gt; str `Consumer msg what group_id You want,You can receive duplicate data using different group_id in same topic`. :param offset_type: Type --&gt; str `LATEST can receive the latest data,EARLIEST can receive earliest data in topic` :raises ParameterError: When use error Parameter to init init_consumer. :return: &quot;&quot;&quot; from kafka import KafkaConsumer if not isinstance(topic, str) or not isinstance(group_id, str) \\ or not isinstance(offset_type, str) or offset_type not in [&quot;LATEST&quot;, &quot;EARLIEST&quot;]: raise ParameterError(ParameterError._ParameterError_kafka_Consumer) self.consumer = KafkaConsumer(bootstrap_servers=self.server, auto_offset_reset=offset_type, group_id=group_id, ) self.consumer.subscribe(topics=topic.split(&#x27;,&#x27;)) def pull(self): &quot;&quot;&quot; Get info from Kafka Consumer by kafka-python Poll Parameters: timeout_ms: Type --&gt; int `Interval between each piece of data`. max_records: Type --&gt; int `The amount of data per batch of data` :return: &quot;&quot;&quot; return self.consumer.poll(timeout_ms=0, max_records=1) def send_message(self, msg, key): &quot;&quot;&quot; Send MSG by this func :param msg: Type --&gt; bytes or str `Message to broker`. :param key: Type --&gt; bytes `Producer msg what key You want,You can see the key when you receiving data`. :raises ParameterError: when error type for key. :return: &quot;&quot;&quot; if not isinstance(key, bytes): raise ParameterError(ParameterError._ParameterError_Key) produce_msg = msg.encode() if isinstance(msg, str) else msg self.producer.produce(produce_msg, partition_key=key)","categories":[{"name":"研发","slug":"研发","permalink":"http://debug.cool/categories/%E7%A0%94%E5%8F%91/"}],"tags":[{"name":"研发","slug":"研发","permalink":"http://debug.cool/tags/%E7%A0%94%E5%8F%91/"},{"name":"Kafka","slug":"Kafka","permalink":"http://debug.cool/tags/Kafka/"},{"name":"Python","slug":"Python","permalink":"http://debug.cool/tags/Python/"}]},{"title":"任务分配算法","slug":"devTaskAssign","date":"2019-01-26T16:00:00.000Z","updated":"2022-11-15T14:33:07.899Z","comments":true,"path":"2019/01/27/devTaskAssign/","link":"","permalink":"http://debug.cool/2019/01/27/devTaskAssign/","excerpt":"在开发一套内部的审核平台的时候，有这么一个需求，所有的任务需要平均的前提下随机分配给审核员。然后有存在一个问题，有的审核员效率慢，有的审核员效率高，这样分配任务的时候就需要考虑审核员当前手上剩余的审核任务(也有运营部的绩效考核原因)。","text":"在开发一套内部的审核平台的时候，有这么一个需求，所有的任务需要平均的前提下随机分配给审核员。然后有存在一个问题，有的审核员效率慢，有的审核员效率高，这样分配任务的时候就需要考虑审核员当前手上剩余的审核任务(也有运营部的绩效考核原因)。 ps：需求变了，所有的都平均分了，因为运营人员不需要根据审核量进行绩效考核了，多劳多得变成大锅饭了。也白设计了这套算法，无所谓了，就当周末刷了会数独游戏吧，反正闲着也是闲着。 假设现在有 n 个任务需要分配给 m 个审核员去完成，但是每个审核员手头上还有未完成的任务，且未完成的任务数不同。那么如何均匀的把这些任务分配给各个审核员？这里我想出了一种基于平均思想的任务分配算法。 该算法的主要思想是：首先找出所有的审核员中手头未完成任务数量最大的审核员，然后其他审核员以该审核员的未完成任务数为参考数，计算自己可容纳的任务数，最后所有审核员可容纳的任务数之和即为总的可容纳任务数。 这里存在两种情况，第一种是：总的可容纳任务数小于或等于 n 个待分配的任务数，此时所有的审核员以最大未完成任务数 max_task 为参考数，接收待分配的任务。如果刚好分配完，那么算法结束；如果还有剩余任务未分配，那么将剩下的任务抽取 m 个任务分配给每一位审核员，以此类推，直到剩下的未分配任务数小于 m 位置，然后将这小于 m 的任务随机分配相应数量的审核员。 第二种情况是：总的可容纳任务数大于 n 个待分配的任务数，此时降低一个单位的参考数(max_task-1)，然后循环计算可容纳的任务数，知道退出循环（循环终止条件为：ava_task - task_num &lt;= lower_List.size(),lower_List.size()表示的是低于当前参考数的审核员数）。 接下来，我们将通过一个简单的例子来说明算法的流程，由于第一种情况比较简单，因此，该例子是基于第二种情况的，如图 1 所示. 假设有 20 个任务需要分配给 8 个审核员(对应 8 个条形图，蓝色条形图对应的数字代表该审核员手头未完成的任务数)。 首先找出者八个审核员收中未完成任务书的最大值 max_task=7，然后个审核员已 max_task 为参考数计算各自可容纳的任务数(绿色条形图对应的数字)，总的可容纳任务数为所有审核员可容纳的任务数之和，及 ava_task=6+3+4+2+5+0+5+6,有图 1 可知，lower_List.size()=7,由 31-20&gt;7，因此，可降低一个单位的参数数，即 max_task=max_task-1=6，如图 2 所示。 那么，ava_task=5+2+3+1+4+0+4+5=24，lower_List.size()=7，由于 24-20&lt;7，因此循环终止。 由于可容纳的任务数仍然大于待分配的任务数，因此需要再降低一个单位的参考数(一定要考虑这种情况)，max_task=max_task-1=5，此时 ava_task=4+1+2+0+3+0+3+4=17，lower_List.size()=6，剩余待分配任务数为 20-17=3，然后将这 3 个任务随机分配给低于当前参考数的 6 个审核员中的 3 个，每个审核员分配一个。 当然算法中还考虑了很多种情况，具体请参见如下代码。由于任务一般按审核员 ID 来分配，且 ID 一般为字符串。为了存储方便，我定义了一个二维字符串类型的数组 rev_task[i][j]来存储数据，i 表示第 i 个审核员，rev_task[i][0]存放的是第 i 个审核员的 ID，rev_task[i][1]存放的是第 i 个审核员当前未完成的任务数，rev_task[i][2]存放的是第 i 个审核员应当被分配的任务数。 算法工具类-AlgorithmUtils.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119package com.audit.allocationAlgorithm;import java.util.ArrayList;import java.util.Date;import java.util.List;import java.util.Random;public class AlgorithmUtils &#123; public static void taskAllocation(int task_num, int rev_num, String[][] rev_task) &#123; Random rd = new Random(); List&lt;Integer&gt; rdList = new ArrayList&lt;&gt;(); int temp; //获得审核人员中的最大未完成任务数 int max_task = Integer.parseInt(rev_task[0][1]); for(int i = 1; i &lt; rev_num; i++)&#123; if(max_task &lt; Integer.parseInt(rev_task[i][1])) max_task = Integer.parseInt(rev_task[i][1]); &#125; //以最大待审核任务数为参考数，判断第一轮可容纳的任务数 int ava_task = 0; List&lt;Integer&gt; lower_List = new ArrayList&lt;&gt;(); for(int i=0;i&lt;rev_num;i++)&#123; if((max_task-Integer.parseInt(rev_task[i][1])) &gt; 0)&#123; ava_task += (max_task-Integer.parseInt(rev_task[i][1])); lower_List.add(i); &#125; &#125; int task_rest; int task_avg; //第一种情况：第一轮可容纳的任务数小于待分配的任务数 if(ava_task - task_num &lt;= 0) &#123; for(int i = 0; i &lt; rev_num; i++) &#123; rev_task[i][2] = String.valueOf(max_task-Integer.parseInt(rev_task[i][1])); &#125; task_rest = task_num-ava_task; task_avg = task_rest/rev_num; if(task_rest != 0) &#123; while(task_avg &gt; 0) &#123; for(int i = 0; i &lt; rev_num; i++) &#123; rev_task[i][2] = String.valueOf(Integer.parseInt(rev_task[i][2])+task_avg); &#125; task_rest -= rev_num*task_avg; task_avg = task_rest/rev_num; &#125; rdList.removeAll(rdList); while(rdList.size() &lt; (task_rest+1))&#123; temp = rd.nextInt(rev_num); if(!rdList.contains(temp))&#123; rdList.add(temp); &#125; &#125; for(int i = 0; i &lt; task_rest; i++) &#123; rev_task[rdList.get(i)][2] = String.valueOf(Integer.parseInt(rev_task[rdList.get(i)][2])+1); &#125; &#125; &#125;else &#123;//第二种情况：第一轮可容纳的任务数大于待分配的任务数，此时降低一个单位的参考数(max_task-1)，然后循环计算可容纳的任务数，直到退出循环 while(ava_task - task_num &gt; lower_List.size()) &#123; max_task--; ava_task = 0; lower_List.removeAll(lower_List); for(int i=0;i&lt;rev_num;i++)&#123; rev_task[i][2] = &quot;0&quot;; if((max_task-Integer.parseInt(rev_task[i][1])) &gt; 0)&#123; rev_task[i][2] = String.valueOf(max_task-Integer.parseInt(rev_task[i][1])); ava_task += Integer.parseInt(rev_task[i][2]); lower_List.add(i); &#125; &#125; &#125; if(ava_task - task_num &gt; 0) &#123;//如果可容纳的任务数大于待分配的任务数，那么需要再再降低一个单位的参考数 max_task--; ava_task = 0; lower_List.removeAll(lower_List); for(int i=0;i&lt;rev_num;i++)&#123; if((max_task-Integer.parseInt(rev_task[i][1])) &gt;= 0)&#123; rev_task[i][2] = String.valueOf(max_task-Integer.parseInt(rev_task[i][1])); ava_task += Integer.parseInt(rev_task[i][2]); lower_List.add(i); &#125; &#125; task_rest = task_num - ava_task; rdList.removeAll(rdList); while(rdList.size() &lt; (task_rest+1))&#123; temp = rd.nextInt(rev_num); if((!rdList.contains(temp))&amp;&amp;(lower_List.contains(temp)))&#123; rdList.add(temp); &#125; &#125; for(int i = 0; i &lt; task_rest; i++) &#123; rev_task[rdList.get(i)][2] = String.valueOf(Integer.parseInt(rev_task[rdList.get(i)][2])+1); &#125; &#125;else &#123; task_rest = task_num-ava_task; if(task_rest != 0) &#123; rdList.removeAll(rdList); while(rdList.size() &lt; (task_rest+1))&#123; temp = rd.nextInt(rev_num); if((!rdList.contains(temp))&amp;&amp;(lower_List.contains(temp)))&#123; rdList.add(temp); &#125; &#125; for(int i = 0; i &lt; task_rest; i++) &#123; rev_task[rdList.get(i)][2] = String.valueOf(Integer.parseInt(rev_task[rdList.get(i)][2])+1); &#125; &#125; &#125; &#125; //记录被分配的任务数 for(int i=0;i&lt;rev_num;i++)&#123; rev_task[i][1] = String.valueOf(Integer.parseInt(rev_task[i][1])+Integer.parseInt(rev_task[i][2])); &#125; &#125;&#125; 算法测试类-TestAlgorithm.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.audit.allocationAlgorithm;import java.util.ArrayList;import java.util.List;import java.util.Random;import java.util.Scanner;public class TestAlgorithm &#123; public static void main(String[] args) &#123; Scanner sc=new Scanner(System.in); System.out.println(&quot;请输入任务数：&quot;); int task_num = sc.nextInt(); System.out.println(&quot;请输入审核人员的当前未完成任务数组，整数数字输入时用英文逗号隔开：&quot;); String inputString=sc.next().toString(); String stringArray[]=inputString.split(&quot;,&quot;); int rev_num = stringArray.length;//审核人员总数 String[][] rev_task =new String[rev_num][3]; Random rd = new Random(); List&lt;Integer&gt; rdList = new ArrayList&lt;&gt;(); rdList.removeAll(rdList); int temp; while(rdList.size() &lt; (rev_num+1))&#123; temp = rd.nextInt(100); if(!rdList.contains(temp))&#123; rdList.add(temp); &#125; &#125; System.out.println(&quot;算法前的任务分配：&quot;); for(int i=0;i&lt;rev_num;i++)&#123; rev_task[i][0] = String.valueOf(rdList.get(i) + 1); rev_task[i][1]= stringArray[i]; rev_task[i][2] = &quot;0&quot;; System.out.print(rev_task[i][0]+&quot;,&quot;+rev_task[i][1]+&quot; &quot;); &#125; System.out.println(); AlgorithmUtils.taskAllocation(task_num, rev_num, rev_task);//调用算法工具类 System.out.println(&quot;算法后的任务分配：&quot;); for(int i=0;i&lt;rev_num;i++)&#123; System.out.print(rev_task[i][0]+&quot;,&quot;+rev_task[i][1]+&quot; &quot;); &#125; &#125;&#125; 运行结果： 12345678请输入任务数：20请输入审核人员的当前未完成任务数组，整数数字输入时用英文逗号隔开：1,4,3,5,2,7,2,1算法前的任务分配：72,1 63,4 73,3 49,5 74,2 43,7 100,2 20,1算法后的任务分配：72,5 63,5 73,5 49,6 74,5 43,7 100,6 20,6 由运行结果可知，20 个任务均衡的分配给了每个审核人员，达到了平均分配的目的！","categories":[{"name":"研发","slug":"研发","permalink":"http://debug.cool/categories/%E7%A0%94%E5%8F%91/"}],"tags":[{"name":"研发","slug":"研发","permalink":"http://debug.cool/tags/%E7%A0%94%E5%8F%91/"},{"name":"算法","slug":"算法","permalink":"http://debug.cool/tags/%E7%AE%97%E6%B3%95/"},{"name":"任务分配","slug":"任务分配","permalink":"http://debug.cool/tags/%E4%BB%BB%E5%8A%A1%E5%88%86%E9%85%8D/"}]},{"title":"Python可视化绘图","slug":"devPythonMatplotlib","date":"2019-01-24T16:00:00.000Z","updated":"2022-11-15T14:31:56.013Z","comments":true,"path":"2019/01/25/devPythonMatplotlib/","link":"","permalink":"http://debug.cool/2019/01/25/devPythonMatplotlib/","excerpt":"Matplotlib是一个Python的绘图库，粗略理解为py集成MATLAB的功能包。以前学数学建模的时候很讨厌MATLAB，情愿用C来写算法都不想学MATLAB，现在没得法，工作需要分析一些数据，还好Python有这些相关的库，要不然真的要去研究下MATLAB了。","text":"Matplotlib是一个Python的绘图库，粗略理解为py集成MATLAB的功能包。以前学数学建模的时候很讨厌MATLAB，情愿用C来写算法都不想学MATLAB，现在没得法，工作需要分析一些数据，还好Python有这些相关的库，要不然真的要去研究下MATLAB了。 简单图形绘制 根据坐标点绘制： 1234567891011import numpy as npimport matplotlib.pyplot as pltx = np.array([1,2,3,4,5,6,7,8])y = np.array([3,5,7,6,2,6,10,15])plt.plot(x,y,&#x27;r&#x27;)# 折线 1 x 2 y 3 colorplt.plot(x,y,&#x27;g&#x27;,lw=10)# 4 line w# 折线 饼状 柱状x = np.array([1,2,3,4,5,6,7,8])y = np.array([13,25,17,36,21,16,10,15])plt.bar(x,y,0.2,alpha=1,color=&#x27;b&#x27;)# 5 color 4 透明度 3 0.9plt.show() 传入参数是 numpy 数组时的效果： 12345678910111213import numpy as npimport matplotlib.pyplot as pltfor i in range(0,15): # 1 柱状图 dateOne = np.zeros([2]) dateOne[0] = i; dateOne[1] = i; y = np.zeros([2]) y[0] = 10 y[1] = 20 plt.plot(dateOne,y,&#x27;r&#x27;,lw=8)plt.show() 根据函数图像绘制： 12345678910111213141516import matplotlib.pyplot as pltimport numpy as np# 从-1-----1之间等间隔采66个数.也就是说所画出来的图形是66个点连接得来的# 注意：如果点数过小的话会导致画出来二次函数图像不平滑x = np.linspace(-1, 1,66)# 绘制y=2x+1函数的图像y = 2 * x + 1plt.plot(x, y)plt.show()# 绘制x^2函数的图像y = x**2plt.plot(x, y)plt.show() figure 的简单使用 12345678910111213141516171819202122232425import matplotlib.pyplot as pltimport numpy as npx = np.linspace(-1, 1, 50)# figure 1y1 = 2 * x + 1plt.figure()plt.plot(x, y1)# figure 2y2 = x**2plt.figure()plt.plot(x, y2)# figure 3，指定figure的编号并指定figure的大小, 指定线的颜色, 宽度和类型#一个坐标轴上画了两个图形y2 = x**2plt.figure(num = 5, figsize = (4, 4))plt.plot(x, y1)plt.plot(x, y2, color = &#x27;red&#x27;, linewidth = 1.0, linestyle = &#x27;--&#x27;)plt.show() 一共会画出三张图，前两张和上面的简单案例画出来的两张一样。 设置坐标轴 12345678910111213141516171819202122232425import matplotlib.pyplot as pltimport numpy as np# 绘制普通图像x = np.linspace(-1, 1, 50)y1 = 2 * x + 1y2 = x**2plt.figure()plt.plot(x, y1)plt.plot(x, y2, color = &#x27;red&#x27;, linewidth = 1.0, linestyle = &#x27;--&#x27;)# 设置坐标轴的取值范围plt.xlim((-1, 1))plt.ylim((0, 3))# 设置坐标轴的lable#标签里面必须添加字体变量：fontproperties=&#x27;SimHei&#x27;,fontsize=14。不然可能会乱码plt.xlabel(u&#x27;这是x轴&#x27;,fontproperties=&#x27;SimHei&#x27;,fontsize=14)plt.ylabel(u&#x27;这是y轴&#x27;,fontproperties=&#x27;SimHei&#x27;,fontsize=14)# 设置x坐标轴刻度, 之前为0.25, 修改后为0.5#也就是在坐标轴上取5个点，x轴的范围为-1到1所以取5个点之后刻度就变为0.5了plt.xticks(np.linspace(-1, 1, 5))plt.show() 上面代码的基础上加上下面代码（直接加载最后一句代码前面即可）： 123456789101112# 获取当前的坐标轴, gca = get current axisax = plt.gca()# 设置右边框和上边框ax.spines[&#x27;right&#x27;].set_color(&#x27;none&#x27;)ax.spines[&#x27;top&#x27;].set_color(&#x27;none&#x27;)# 设置x坐标轴为下边框ax.xaxis.set_ticks_position(&#x27;bottom&#x27;)# 设置y坐标轴为左边框ax.yaxis.set_ticks_position(&#x27;left&#x27;)# 设置x轴, y周在(0, 0)的位置ax.spines[&#x27;bottom&#x27;].set_position((&#x27;data&#x27;, 0))ax.spines[&#x27;left&#x27;].set_position((&#x27;data&#x27;, 0)) 如果在上面代码的最后一句之前加上下面的代码： 1234# 设置坐标轴label的大小，背景色等信息for label in ax.get_xticklabels() + ax.get_yticklabels(): label.set_fontsize(12) label.set_bbox(dict(facecolor = &#x27;green&#x27;, edgecolor = &#x27;None&#x27;, alpha = 0.7)) 设置 legend 图例 123456789101112131415161718192021222324252627282930313233343536373839404142&quot;&quot;&quot;设置坐标轴&quot;&quot;&quot;import matplotlib.pyplot as pltimport numpy as np# 绘制普通图像x = np.linspace(-1, 1, 50)y1 = 2 * x + 1y2 = x**2plt.figure()plt.plot(x, y1)plt.plot(x, y2, color = &#x27;red&#x27;, linewidth = 1.0, linestyle = &#x27;--&#x27;)# 设置坐标轴的取值范围plt.xlim((-1, 1))plt.ylim((0, 3))# 设置坐标轴的lable#标签里面必须添加字体变量：fontproperties=&#x27;SimHei&#x27;,fontsize=14。不然可能会乱码plt.xlabel(u&#x27;这是x轴&#x27;,fontproperties=&#x27;SimHei&#x27;,fontsize=14)plt.ylabel(u&#x27;这是y轴&#x27;,fontproperties=&#x27;SimHei&#x27;,fontsize=14)# 设置x坐标轴刻度, 之前为0.25, 修改后为0.5#也就是在坐标轴上取5个点，x轴的范围为-1到1所以取5个点之后刻度就变为0.5了plt.xticks(np.linspace(-1, 1, 5))# 获取当前的坐标轴, gca = get current axisax = plt.gca()# 设置右边框和上边框ax.spines[&#x27;right&#x27;].set_color(&#x27;none&#x27;)ax.spines[&#x27;top&#x27;].set_color(&#x27;none&#x27;)# 设置x坐标轴为下边框ax.xaxis.set_ticks_position(&#x27;bottom&#x27;)# 设置y坐标轴为左边框ax.yaxis.set_ticks_position(&#x27;left&#x27;)# 设置x轴, y周在(0, 0)的位置ax.spines[&#x27;bottom&#x27;].set_position((&#x27;data&#x27;, 0))ax.spines[&#x27;left&#x27;].set_position((&#x27;data&#x27;, 0))plt.show() 添加注解和绘制点以及在图形上绘制线或点 1234567891011121314151617181920212223242526272829303132333435363738394041&quot;&quot;&quot;添加注解和绘制点以及在图形上绘制线或点&quot;&quot;&quot;import matplotlib.pyplot as pltimport numpy as np# 绘制普通图像x = np.linspace(-3, 3, 50)y = 2 * x + 1plt.figure()plt.plot(x, y)# 将上、右边框去掉ax = plt.gca()ax.spines[&#x27;right&#x27;].set_color(&#x27;none&#x27;)ax.spines[&#x27;top&#x27;].set_color(&#x27;none&#x27;)# 设置x轴的位置及数据在坐标轴上的位置ax.xaxis.set_ticks_position(&#x27;bottom&#x27;)ax.spines[&#x27;bottom&#x27;].set_position((&#x27;data&#x27;, 0))# 设置y轴的位置及数据在坐标轴上的位置ax.yaxis.set_ticks_position(&#x27;left&#x27;)ax.spines[&#x27;left&#x27;].set_position((&#x27;data&#x27;, 0))# 定义(x0, y0)点x0 = 1y0 = 2 * x0 + 1# 绘制(x0, y0)点plt.scatter(x0, y0, s = 50, color = &#x27;blue&#x27;)# 绘制虚线plt.plot([x0, x0], [y0, 0], &#x27;k--&#x27;, lw = 2.5)# 绘制注解一plt.annotate(r&#x27;$2 * x + 1 = %s$&#x27; % y0, xy = (x0, y0), xycoords = &#x27;data&#x27;, xytext = (+30, -30), \\ textcoords = &#x27;offset points&#x27;, fontsize = 16, arrowprops = dict(arrowstyle = &#x27;-&gt;&#x27;, connectionstyle = &#x27;arc3, rad = .2&#x27;))# 绘制注解二plt.text(-3, 3, r&#x27;$Test\\ text. \\mu \\sigma_i, \\alpha_i$&#x27;, fontdict = &#123;&#x27;size&#x27;: 16, &#x27;color&#x27;: &#x27;red&#x27;&#125;)plt.show() 绘制散点图 1234567891011121314151617181920212223242526&quot;&quot;&quot;绘制散点图&quot;&quot;&quot;import numpy as npimport matplotlib.pyplot as plt# 数据个数n = 1024# 均值为0, 方差为1的随机数x = np.random.normal(0, 1, n)y = np.random.normal(0, 1, n)# 计算颜色值color = np.arctan2(y, x)# 绘制散点图plt.scatter(x, y, s = 75, c = color, alpha = 0.5)# 设置坐标轴范围plt.xlim((-1.5, 1.5))plt.ylim((-1.5, 1.5))# 不显示坐标轴的值plt.xticks(())plt.yticks(())plt.show() 绘制柱状图 1234567891011121314151617181920212223242526272829303132333435&quot;&quot;&quot;绘制柱状图&quot;&quot;&quot;import matplotlib.pyplot as pltimport numpy as np# 数据数目n = 10x = np.arange(n)# 生成数据, 均匀分布(0.5, 1.0)之间y1 = (1 - x / float(n)) * np.random.uniform(0.5, 1.0, n)y2 = (1 - x / float(n)) * np.random.uniform(0.5, 1.0, n)# 绘制柱状图, 向上plt.bar(x, y1, facecolor = &#x27;blue&#x27;, edgecolor = &#x27;white&#x27;)# 绘制柱状图, 向下plt.bar(x, -y2, facecolor = &#x27;green&#x27;, edgecolor = &#x27;white&#x27;)temp = zip(x, y2)# 在柱状图上显示具体数值, ha水平对齐, va垂直对齐for x, y in zip(x, y1): plt.text(x + 0.05, y + 0.1, &#x27;%.2f&#x27; % y, ha = &#x27;center&#x27;, va = &#x27;bottom&#x27;)for x, y in temp: plt.text(x + 0.05, -y - 0.1, &#x27;%.2f&#x27; % y, ha = &#x27;center&#x27;, va = &#x27;bottom&#x27;)# 设置坐标轴范围plt.xlim(-1, n)plt.ylim(-1.5, 1.5)# 去除坐标轴plt.xticks(())plt.yticks(())plt.show() 绘制登高线图 12345678910111213141516171819202122232425262728293031&quot;&quot;&quot;绘制登高线图&quot;&quot;&quot;import matplotlib.pyplot as pltimport numpy as np# 定义等高线高度函数def f(x, y): return (1 - x / 2 + x ** 5 + y ** 3) * np.exp(- x ** 2 - y ** 2)# 数据数目n = 256# 定义x, yx = np.linspace(-3, 3, n)y = np.linspace(-3, 3, n)# 生成网格数据X, Y = np.meshgrid(x, y)# 填充等高线的颜色, 8是等高线分为几部分plt.contourf(X, Y, f(X, Y), 8, alpha = 0.75, cmap = plt.cm.hot)# 绘制等高线C = plt.contour(X, Y, f(X, Y), 8, colors = &#x27;black&#x27;, linewidth = 0.5)# 绘制等高线数据plt.clabel(C, inline = True, fontsize = 10)# 去除坐标轴plt.xticks(())plt.yticks(())plt.show() 绘制 Image 12345678910111213141516&quot;&quot;&quot;绘制Image&quot;&quot;&quot;import matplotlib.pyplot as pltimport numpy as np# 定义图像数据a = np.linspace(0, 1, 9).reshape(3, 3)# 显示图像数据plt.imshow(a, interpolation = &#x27;nearest&#x27;, cmap = &#x27;bone&#x27;, origin = &#x27;lower&#x27;)# 添加颜色条plt.colorbar()# 去掉坐标轴plt.xticks(())plt.yticks(())plt.show() 绘制 3D 图形 1234567891011121314151617181920212223242526272829303132333435&quot;&quot;&quot;绘制3d图形&quot;&quot;&quot;import matplotlib.pyplot as pltimport numpy as npfrom mpl_toolkits.mplot3d import Axes3D# 定义figurefig = plt.figure()# 将figure变为3dax = Axes3D(fig)# 数据数目n = 256# 定义x, yx = np.arange(-4, 4, 0.25)y = np.arange(-4, 4, 0.25)# 生成网格数据X, Y = np.meshgrid(x, y)# 计算每个点对的长度R = np.sqrt(X ** 2 + Y ** 2)# 计算Z轴的高度Z = np.sin(R)# 绘制3D曲面ax.plot_surface(X, Y, Z, rstride = 1, cstride = 1, cmap = plt.get_cmap(&#x27;rainbow&#x27;))# 绘制从3D曲面到底部的投影ax.contour(X, Y, Z, zdim = &#x27;z&#x27;, offset = -2, cmap = &#x27;rainbow&#x27;)# 设置z轴的维度ax.set_zlim(-2, 2)plt.show() subplot 绘制多图 123456789101112131415161718192021&quot;&quot;&quot;subplot绘制多图&quot;&quot;&quot;import matplotlib.pyplot as pltplt.figure()# 绘制第一个图plt.subplot(2, 2, 1)plt.plot([0, 1], [0, 1])# 绘制第二个图plt.subplot(2, 2, 2)plt.plot([0, 1], [0, 1])# 绘制第三个图plt.subplot(2, 2, 3)plt.plot([0, 1], [0, 1])# 绘制第四个图plt.subplot(2, 2, 4)plt.plot([0, 1], [0, 1])plt.show() 123456789101112131415161718192021&quot;&quot;&quot;subplot绘制多图&quot;&quot;&quot;import matplotlib.pyplot as pltplt.figure()# 绘制第一个图plt.subplot(2, 1, 1)plt.plot([0, 1], [0, 1])# 绘制第二个图plt.subplot(2, 3, 4)plt.plot([0, 1], [0, 1])# 绘制第三个图plt.subplot(2, 3, 5)plt.plot([0, 1], [0, 1])# 绘制第四个图plt.subplot(2, 3, 6)plt.plot([0, 1], [0, 1])plt.show() figure 绘制多图 12345678910111213141516171819202122232425&quot;&quot;&quot;figure绘制多图&quot;&quot;&quot;import matplotlib.pyplot as plt# 定义figureplt.figure()# figure分成3行3列, 取得第一个子图的句柄, 第一个子图跨度为1行3列, 起点是表格(0, 0)ax1 = plt.subplot2grid((3, 3), (0, 0), colspan = 3, rowspan = 1)ax1.plot([0, 1], [0, 1])ax1.set_title(&#x27;Test&#x27;)# figure分成3行3列, 取得第二个子图的句柄, 第二个子图跨度为1行3列, 起点是表格(1, 0)ax2 = plt.subplot2grid((3, 3), (1, 0), colspan = 2, rowspan = 1)ax2.plot([0, 1], [0, 1])# figure分成3行3列, 取得第三个子图的句柄, 第三个子图跨度为1行1列, 起点是表格(1, 2)ax3 = plt.subplot2grid((3, 3), (1, 2), colspan = 1, rowspan = 1)ax3.plot([0, 1], [0, 1])# figure分成3行3列, 取得第四个子图的句柄, 第四个子图跨度为1行3列, 起点是表格(2, 0)ax4 = plt.subplot2grid((3, 3), (2, 0), colspan = 3, rowspan = 1)ax4.plot([0, 1], [0, 1])plt.show() 或 123456789101112131415161718192021222324252627&quot;&quot;&quot;figure绘制多图&quot;&quot;&quot;import matplotlib.pyplot as pltimport matplotlib.gridspec as gridspec# 定义figureplt.figure()# 分隔figuregs = gridspec.GridSpec(3, 3)ax1 = plt.subplot(gs[0, :])ax2 = plt.subplot(gs[1, 0:2])ax3 = plt.subplot(gs[1, 2])ax4 = plt.subplot(gs[2, :])# 绘制图像ax1.plot([0, 1], [0, 1])ax1.set_title(&#x27;Test&#x27;)ax2.plot([0, 1], [0, 1])ax3.plot([0, 1], [0, 1])ax4.plot([0, 1], [0, 1])plt.show() figure 图的嵌套 1234567891011121314151617181920212223242526272829303132333435363738394041424344&quot;&quot;&quot;figure图的嵌套&quot;&quot;&quot;import matplotlib.pyplot as plt# 定义figurefig = plt.figure()# 定义数据x = [1, 2, 3, 4, 5, 6, 7]y = [1, 3, 4, 2, 5, 8, 6]# figure的百分比, 从figure 10%的位置开始绘制, 宽高是figure的80%left, bottom, width, height = 0.1, 0.1, 0.8, 0.8# 获得绘制的句柄ax1 = fig.add_axes([left, bottom, width, height])# 绘制点(x,y)ax1.plot(x, y, &#x27;r&#x27;)ax1.set_xlabel(&#x27;x&#x27;)ax1.set_ylabel(&#x27;y&#x27;)ax1.set_title(&#x27;test&#x27;)# 嵌套方法一# figure的百分比, 从figure 10%的位置开始绘制, 宽高是figure的80%left, bottom, width, height = 0.2, 0.6, 0.25, 0.25# 获得绘制的句柄ax2 = fig.add_axes([left, bottom, width, height])# 绘制点(x,y)ax2.plot(x, y, &#x27;r&#x27;)ax2.set_xlabel(&#x27;x&#x27;)ax2.set_ylabel(&#x27;y&#x27;)ax2.set_title(&#x27;part1&#x27;)# 嵌套方法二plt.axes([bottom, left, width, height])plt.plot(x, y, &#x27;r&#x27;)plt.xlabel(&#x27;x&#x27;)plt.ylabel(&#x27;y&#x27;)plt.title(&#x27;part2&#x27;)plt.show() 主次坐标轴 12345678910111213141516171819202122232425&quot;&quot;&quot;主次坐标轴&quot;&quot;&quot;import numpy as npimport matplotlib.pyplot as plt# 定义数据x = np.arange(0, 10, 0.1)y1 = 0.05 * x ** 2y2 = -1 * y1# 定义figurefig, ax1 = plt.subplots()# 得到ax1的对称轴ax2ax2 = ax1.twinx()# 绘制图像ax1.plot(x, y1, &#x27;g-&#x27;)ax2.plot(x, y2, &#x27;b--&#x27;)# 设置labelax1.set_xlabel(&#x27;X data&#x27;)ax1.set_xlabel(&#x27;Y1&#x27;, color = &#x27;g&#x27;)ax2.set_xlabel(&#x27;Y2&#x27;, color = &#x27;b&#x27;)plt.show() 创建动画 1234567891011121314151617181920212223242526272829303132333435&quot;&quot;&quot;动画&quot;&quot;&quot;import numpy as npimport matplotlib.pyplot as pltfrom matplotlib import animation# 定义figurefig, ax = plt.subplots()# 定义数据x = np.arange(0, 2 * np.pi, 0.01)# line, 表示只取返回值中的第一个元素line, = ax.plot(x, np.sin(x))# 定义动画的更新def update(i): line.set_ydata(np.sin(x + i/10)) return line,# 定义动画的初始值def init(): line.set_ydata(np.sin(x)) return line,# 创建动画ani = animation.FuncAnimation(fig = fig, func = update, init_func = init, interval = 10, blit = False, frames = 200)# 展示动画plt.show()# 动画保存#我这里是保存为html文件了，打开即可完美运行ani.save(&#x27;sin.html&#x27;, writer = &#x27;imagemagick&#x27;, fps = 30, dpi = 100)","categories":[{"name":"研发","slug":"研发","permalink":"http://debug.cool/categories/%E7%A0%94%E5%8F%91/"}],"tags":[{"name":"研发","slug":"研发","permalink":"http://debug.cool/tags/%E7%A0%94%E5%8F%91/"},{"name":"Python","slug":"Python","permalink":"http://debug.cool/tags/Python/"},{"name":"笔记","slug":"笔记","permalink":"http://debug.cool/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Matplotlib","slug":"Matplotlib","permalink":"http://debug.cool/tags/Matplotlib/"}]},{"title":"逆向笔记梳理","slug":"devReverseEnfineering","date":"2018-10-09T23:33:25.000Z","updated":"2022-11-15T14:50:47.465Z","comments":true,"path":"2018/10/10/devReverseEnfineering/","link":"","permalink":"http://debug.cool/2018/10/10/devReverseEnfineering/","excerpt":"先把大纲列出来，有空就慢慢更新完善。","text":"先把大纲列出来，有空就慢慢更新完善。 x86 与 x64 x86是基于intel 8086处理器的小端（little-endian）体系结构（IA-32的32位实现），他在两种操作模式下执行 实模式：处理机刚刚上电后只支持 16 位指令集的状态。 保护模式：处理机支持虚拟内存、分页及其他功能的状态。 该体系的64位扩展称为x64或x86-64，x86通过一种称为环级别(ring level)的抽象来支持特权隔离(privilege separation)。 寄存器组与数据类型 运行于保护模式下的x86体系结构有 8 个32位通用寄存器(General Purpose Registers, GPR):EAX、EBX、ECX、EDX、EDI、ESI、EBP、ESP。这些寄存器还能进一步分化成8位和16位寄存器。指令指针存储在EIP寄存器中。 12345678910111213141531 23 15 7 0| EAX || | | AX || | |AH |AL |31 23 15 7 0 31 23 15 7 0| EBP | | ESP || | BP | | | SP |31 23 15 7 0 31 23 15 7 0| ESI | | EDI || | SI | | | DI |31 23 15 7 0 31 23 15 7 0| EIP | | EFLAGS | 寄存器 用途 ECX 循环计数 ESI 字符串/内存操作的源 EDI 字符串/内存操作中的目标 EBP 帧基指针 ESP 栈指针 常用的数据类型有以下几种： 字节(Byte): 8 位，比如 AL、BL、CL。 字(Word): 16 位，比如 AX、BX、CX。 双字(Double Word): 32 位，比如 EAX、EBX、ECX。 四字(Quad Word): 64 位，虽然 x86 并不支持 64 位 GPR，但是在某些场景下可以把两个寄存器(通常是 EDA:EAX)的内容合并起来当作 64 位的值。比如 RDTSC 指令会把一个 64 位值写入 EDX:EAX 寄存器。 32位寄存器EFLAGS用于存储运算状态以及其他运行状态（比如陷阱标志位）。 除了通用寄存器、EIP和EFLAGS，还有一些寄存器用于控制重要的底层系统机制，比如虚拟内存、终端和调试等。例如：CR0寄存器控制分页机制的开关，CR2寄存器中保存着导致缺页异常发生的线性地址，CR3是分页数据结构的基地址，CR4控制硬件虚拟化设置。DR0～DR7寄存器用于设置内存断点。（注意，虽然调试寄存器有 8 个，但系统只支持 4 个内存断点DR0～DR3，其余寄存器用于保存状态） 指令集 x86指令集为寄存器和内存之间的数据移动提供了很大的灵活性。数据移动可以分为 5 种方式： 立即数到寄存器 寄存器到寄存器 立即数到内存 寄存器到内存，或反向 内存到内存 前四种是所有现代体系结构都支持的，而最后一种是x86独有的。像 ARM 这样的经典RISC体系结构只支持通过加载/存储指令（LDR/STR）从内存读出或反向内存写入数据。比如递增内存中数据值需要执行 3 条指令： 把数据从内存读入到寄存器中（LDR） 寄存器加 1（ADD） 把寄存器值写回内存（STR） 而对已x86来说，因为可以直接访问内存，这样的操作只需要一条指令（INC或ADD）。MOVS指令可以同时读写内存。 ARM： 1234561B 68 LDR R3, [R3]; 读入地址R3处的值并保存在R2中5A 1C ADDS R2, R3, #1; 加11A 60 STR R2, [R3]; 把更新后的值写回地址R3处 x86： 12FF 00 inc dword ptr [eax]; 直接递增地址EAX处的值 x86的另一个重要特性是使用了变长指令——指令的长度从1到15字节不等。而在ARM上，指令长度只能是2字节或4字节。 语法 根据汇编器/反汇编器的不同，x86 汇编代码有两种记法：Intel和AT&amp;T。 Intel(Windows 上的记法)： 123mov ecx, AABBCCDDhmov ecx, [eax]mov ecx, eax AT&amp;T(unix 上的 GCC 记法): 123movl $0xAABBCCDD, %ecxmovl (%eax), %ecxmovl %eax, %ecx AT&amp;T 记法在寄存器前加前缀%，立即数前加$。Intel 记法不加前缀。 AT&amp;T 记法加入了指示指令宽度的后缀，比如 MOVL(长整型)、MOVB(字节)等。Intel 记法没有这种标记。 AT&amp;T 记法把源操作数放在目标操作数之前。Intel 记法与之相反。 数据移动 指令用于操作来自寄存器或主内存中的数据。 栈操作与函数调用 C 语言的局部变量就存储在函数的栈空间中。操作系统从ring3切换到ring0时，要把状态信息保存在栈上。具体来讲，x86上的栈是ESP指向的一段连续内存区域，他向下增长。压栈（push指令）递减ESP的值，然后把数据写入 ESP 指向的位置；出栈（pop指令）读出ESP指向位置的数据并递增ESP。默认的自动递增/递减值为 4，但是通过前缀这个值也可以替换为 1 或 2。实际上，这个值几乎总是 4，因为 OS 要求栈双字对齐。 假定ESP最初指向0xb20000，然后执行下面的代码： 12345678910111213; 起始值ESP=0xb20000B8 AA AA AA AA MOV EAX,0AAAAAAAAhBB BB BB BB BB MOV EBX,0BBBBBBBBhB9 CC CC CC CC MOV ECX,0CCCCCCCChBA DD DD DD DD MOV EDX,0DDDDDDDDh50 PUSH EAX; 地址0xb1fffc值将会是0xAAAAAAAA，ESP将会是0xb1fffc （=0xb20000-4）53 PUSH EBX; 地址0xb1fff8的值将会是0xBBBBBBBB，ESP将会是0xb1fff8 （=0xb1fffc-4）5E POP ESI; ESI值将会是0xBBBBBBBB，ESP将会是0xb1fffc （=0xb1fff8+4）5F POP EDI; EDI值将会是0xAAAAAAAA，ESP将会是0xb20000 （=0xb1fffc+4） 其他一些指令也可以直接修改ESP，比如ADD和SUB 高级语言中有函数的概念，函数可以被调用也可以返回，而处理器本身并没有提供这样的抽象。在最底层，处理器只操作具体对象，比如寄存器或内存中的数据。在机器语言这一层级通过栈数据结构来实现函数。 C 代码： 12345int__cdecl addme(short a, short b)&#123; rerurn a+b;&#125; 汇编代码： 12345678910004113A0 55 push ebp004113A1 8B EC mov ebp, esp...004113BE 0F BF 45 08 movsx eax, word ptr [ebp+8]004113C2 0F BF 4D 0C movsx ecx, word ptr [ebp+0ch]...004113CB 8B E5 mov esp, ebp004113CD 5D pop ebp004113CE C3 retn; retn 指令就是把存储在栈顶的地址出栈到EIP，然后把控制传递给他（完全与POP EIP类似，但是x86上并没有这样的指令序列） 通过下面的代码调用函数： C 代码 1sum = addme(x,y); 汇编代码 12345004129F3 50 push eax...004129F8 51 push ecx004129F9 E8 F1 E7 FF FF call addme004129FE 83 C4 08 add esp, 8 先了解一下调用惯例，调用惯例规定了在机器层面如何进行函数调用。对于特定的系统来说他是由应用程序二进制接口(Application Binary Interface, ABI)所定义的。 调用惯例 CDECL STDCALL FASTCALL 参数 从右向左压栈。调用方负责在调用后清理栈 与 CDECL 相同，除了被调用方负责清理栈 前两个参数通过 ECX 和 EDX 传递。其余压栈 返回值 保存在 EAX 中 保存在 EAX 中 保存在 EAX 中 非易失寄存器 EBP、ESP、EBX、ESI、EDI EBP、ESP、EBX、ESI、EDI EBP、ESP、EBX、ESI、EDI 现在我们回到前面的代码片段来讨论函数addme是如何被调用的。 在第 1 行和第 3 行代码中把两个参数压入栈顶，EXC和EAX分别是第一个和第二个参数。第四行代码通过CALL指令调用了addme函数。这立即导致返回地址0x4120FE被压栈，然后0x4113A0处开始执行。 第 4 行代码执行后，就进入了addme函数的函数体。第 1 行代码把EBP压栈。第 2 行代码把EBP设置为指向当前栈顶。这个二指令序列建立了一个新的函数帧，因此通常称为函数序言（function prologue）第 4 行代码读入地址EBP+8的值，他是栈的第一个参数。第 5 行代码读入第二个参数。注意参数访问是以EBP作为基地址的。在这个上下文环境中，EBP被称为帧基指针，因为他指向了当前函数的栈帧，参数和局部变量都可以通过相对他的地址来访问。也可以通过一种称为帧指针省略（frame pointer omission）的优化方法指定编译器生成不使用EBP作为帧指针的代码。这种优化下，局部变量和参数的访问是相对ESP进行的，这时EBP可以作为一个通用寄存器，就像EAX、EBX、EXC等寄存器一样。第六行代码执行数字的加运算，并把结果放入EAX中。第 8 行代码把栈指针设为帧指针。第 9 行代码将之前第 1 行中保存的EBP数值出栈到EBP。这个二指令序列结束了当前的函数调用，并恢复了函数调用前的栈帧通常称为函数尾声（function epilogue）。这个时间点上，栈顶值为CALL指令保存的返回地址0x4129F9。第 10 行执行RET指令，这个指令将栈顶元素出栈并从0x4129FE开始继续执行。代码中的第 5 行把栈收缩了 8 字节大小，因为根据CDECL调用惯例的规定，栈清理的工作必须由调用者完成。 如果函数addme有局部变量，那么代码需要在第 2 行之后通过减小ESP值来增长栈大小。然后所有的局部变量都可以通过EBP加上一个负的偏移量来访问。 控制流 ZF(Zero Flag， 零标志位)：指示之前算术运算的结果是否为 0 SF(Sifn Flag， 符号标志位)：设为当前结果的最高有效位 CF(Carry Flag， 借位标志位)： 指示当前结果是否需要借位。对无符号整数有效。 OF(Over Flag， 溢出标志位)： 只是当前结果是是否超过了最大值。对有符号整数有效。 算术运算指令会根据计算结果更新这些标志位。举例来说，SUB EAX,EAX指令会引起 ZF 标志的设置。Jcc指令会根据这些标志位改变控制流，其中cc是某个条件代码(conditional code)，该指令最多支持 16 中条件代码。 条件代码 跳转条件 机器描述 JZ/JE 若为 0；若相等 ZF = 1 JNZ/JNE 若不为 0；若不相等 ZF = 0 JS 若为负 SF = 1 JNS 若不为负 SF = 0 JP/JPE 若 1 出现的次数为偶数 PF = 1 JNP/JPO 若 1 出现的次数为奇数 PF = 0 JO 若溢出 OF = 1 JNO 若无溢出 OF = 0 JC/JB/JNAE 若进位；若低于；若不高于等于 CF = 1 JNC/JNB/JAE 若无进位；若不低于；若高于等于 CF = 0 JBE/JNA 若低于等于；若不高于 ZF = 1 或 CF = 1 JNBE/JA 若不低于等于；若高于 ZF = 0 或 CF = 0 JL/JNGE 若小于；若不大于等于 SF != OF JNL/JGE 若不小于；若大于等于 SF = OF JLE/JNG 若小于等于；若不大于 ZF != OF 或 ZF = 1 JNLE/JG 若不小于等于；若大于 SF = 0 且 ZF = 0 系统机制 两种基础系统机制：虚拟地址转换（virtual address translation）和异常/中断处理（exception/interrupt handling） 地址转换 计算机系统中的物理内存以4KB为单元作为一个页（page）。实际上页的大小也可以超过4KB，这里我们不讨论其他尺寸的页。内存地址分为两种：虚拟内存和物理内存。在分页启动的情况下，处理器执行的指令中使用的地址是虚拟地址。举例来说： 12A1 78 56 34 12 MOV EAX, [0x12345678] ; 读入虚内地址为0x12345678的内存89 08 MOV [EAX], ECX ; 把ECX写入虚拟地址为EAX处 物理地址是处理器访问内存时使用的实际内存地址。处理器的MMU(Memory Management Unit， 内存管理单元)在访问内存之前透明地把虚拟地址转换为物理地址。在用户开来虚拟地址就是一个数字，而对于MMU来说这个地址则是结构化的。在支持PAE(Physical Address Extension， 物理地址扩展)的x86系统上，虚拟地址可以划分为几个部分，作为偏移量索引到三个表中，包括PDPT(Page Directory Pointer Table，页目录指针表)、PD(Page Directory，页目录)、PT(Page Table， 页表)以及PTE(Page Table Entry，页表项)。PDPT是4个元素的数组，每个元素8字节，指向一个PD。PD是一个有512个元素的数组，每个元素8字节，指向一个PT。PT也是一个有512个元素的数组，每个元素8字节，指向一个PTE。以虚拟地址0xBF80EE6B(转换成二进制：10111111 10000000 11101110 01101011)来理解，如下表： 10(0x2) 111111 100(0x1FC) 00000 1110(0xE) 1110 01101011(0xE6B) 2 位 9 位 9 位 12 位 索引到 PDPT 索引到 PD 索引到 PT 页偏移量 这些表中的 8 字节元素包含关于表、内存访问许可以及其他内存属性的数据。比如，其中有一些位用于标识这个页是只读还是可读写、是否可执行、用户是否可以访问等。 地址转换过程就围绕着这 3 个表和CR3寄存器。CR3寄存器保存着PDPT的物理基地址。 中断与异常 简单讲就是操作系统通过中断和异常机制实现系统调用，完整的实现细节参考 Windows 内核部分。 x64 x64是x86的扩展，所有两者的绝大多数体系结构特性都一样，只有略微不同，比如寄存器宽度，以及某些指令不可再用(比如PUSHAD)。 寄存器组与数据类型补充 x64的寄存器组有18个64位GPR，下面画图解释这些寄存器的结构，注意前缀为R的是64位寄存器。 123456789101164 . . . 31 23 15 7 0|RAX | | | | | | | || | | | |EAX | | | || | | | | | | AX | || | | | | | | AH | AL |64 . . . 31 23 15 7 0|RBP | | | | | | | || | | | |EBP | | | || | | | | | | BP | || | | | | | | | BPL | 虽然RBP任然可以用作帧基指针，但实际应用中编译器生成的代码很少这么用，多数x64编译器只是把RBP当作GPR来用，而用RSP作为基地址引用局部变量。 数据移动补充 x64支持一种称为RIP相对寻址(RIP-relative addressing)的概念，其允许指令引用数据时使用相对RIP的地址。例如： 123450000000000000000 48 8B 05 00 00+ mov rax, qword ptr cs:loc_A ; 最开始写作&quot;mov rax,[rip]&quot;0000000000000007 loc_A:0000000000000007 48 31 C0 xor rax,rax000000000000000A 90 nop 第 1 行读入loc_A的地址（为0x7）然后保存到RAX中。RIP相对寻址主要用于产生位置无关代码。 多数算术运算指令都自动升级为64位，即使操作数只有32位。例如： 123448 B8 88 77 66+ mov rax, 1122334455667788h31 C0 xor eax, eax ; 也会清除RAX的高32位，也就是说执行后RAX=048 C7 C0 FF FF+ mov rax, 0FFFFFFFFFFFFFFFFhFF C0 inc eax ; 执行后RAX=0 规范地址 x64中虚拟地址的宽度是64位，但多数处理器并不支持完整的64位虚拟地址空间。当前Intel/AMD处理器只使用48位地址空间。所有的虚拟地址必须为规范形式。如果一个虚拟地址从第63位到具体实现的最高有效位都是1或者都是0，那么这个虚拟地址就称为规范地址。具体来说，这意味着从48到63位都要和47位相同。如果代码引用一个非规范地址，就会触发系统异常。 函数调用 x86上有一些调用惯例需要通过栈来传递一些参数。对于x64来说，多数调用惯例都是通过寄存器传递参数，比如在windows x64中，只有一种调用惯例用到栈，并且其中前四个参数还是通过RCX、RDX、R8和R9来传递的；其余的参数按照从左到右的顺序压栈。Linux 上，则是前 6 个参数通过RDI、RSI、RDX、RCX、R8和R9传递。 ------------------------本次更新时间 2018-10-16 10:53 ARM 这里介绍的是ARM Architecture Reference Manual ARMv7-A and ARMv777-R Edition (ARM DDI 0406B)中定义的ARM体系结构。 基本特性 ARM是RISC体系结构，因此与CISC体系结构(x86/x64)有一些基本区别。(从实践的角度说，最新版本的Intel处理器也具有一些RISC的特征；也就是说，他们已经不再是纯粹的CISC。)首先，与x86相比，ARM的指令集是很小的，但是提供的通用寄存器更多。第二，指令的宽度是固定的（16位或32位，根据当前状态而定）。第三，ARM的内存访问模式是加载-存储模式。这意味着操作数据之前必须先要把它从内存加载到寄存器中。只有加载/存储指令能够访问内存，具体来说，在ARM中是LDR和STR指令。如果要递增某个内存地址上的32位数值，必须先把数值从这个地址加载到寄存器中，递增，然后再存储回去。x86则允许大多数指令直接操作内存中的数据，只需要简单的加载，操作，递增三步。 ARM还提供了几种不同级别的特权模式来实现特权隔离。x86上的特权级别是通过 4 种ring级别定义的，其中ring0具有最高特权级别，ring3的特权级别最低。在ARM中，有 8 种不同级别的特权模式： USR(USER,用户模式) FIQ(FAST INTERRUPT REQUEST,快速中断请求模式) IRQ(INTERRUPT REQUEST,中断请求模式) SVC(SUPERVISOR, 管理模式) MON(MONITOR,监视模式) ABT(ABORT,中止模式) UND(UNDERFINED,未定义指令模式) SYS(SYSTEM,系统模式) 多数操作系统内核模式运行于SVC。在Windows或Linux上都是。 x64处理器可以运行在32位或64位模式下，也可以交替运行于这两种模式下。ARM处理与之类似，他们也可以运行在两种状态下：ARM和Thumb状态。ARM/Thumb状态决定的只有指令集，而不是特权模式。比如运行子啊在ARM状态下，指令总是32位宽；而在Thumb下，指令可以是16位宽也可以是32位宽。决定处理器执行状态的是以下两个因素。 通过 BX 和 BLX 指令进行分支跳转的时候，如果目标寄存器的最低有效位是 1，就切换到 Thumb 状态。（尽管指令是 2 字节对齐或 4 字节对齐的，但处理器会忽略最低有效位，因此不会有对齐的问题。） 如果当前程序状态寄存器（CPSR）中的 T 标志位被置起，就处于 Thumb 模式。CPSR 的语义会在之后详述，目前可以把它类比为 x86 中扩展的 EFLAGS 寄存器。 ARM核心启动的时候，多数情况下都是进入ARM状态并保持在这个状态，知道显式或隐式地切换到Thumb模式。具体实践中，多数较新的操作系统使用Thumb代码是为了获得更高的代码密度（混合使用16/32位宽度指令的代码大小小于全部使用32位指令），而且应用程序可以运行于任意模式下。因为多数Thumb和ARM指令助记符都是相同的，所以在32位Thumb指令后添加一个.W后缀标识。 注意，有一种很常见的误解，就是把Thumb模式看作x86/x64上的实模式，把ARM模式看作保护模式。x86/x64平台上的绝大多数操作系统运行于保护模式，很少会切换回实模式。位ARM平台上的操作系统和应用程序则可以交替运行于ARM状态和Thumb状态。还要注意，这两个状态与前面介绍的特权模式也是完全不同的概念。 Thumb有两个版本：Thumb-1和Thumb-2。Thumb-1用于ARMv6和更早期的体系结构，指令集宽度都是16位。Thumb-2增加了更多的指令，并支持16位和32位的指令宽度。ARMv7只用Thumb-2，所以只要是讨论Thumb，都是Thumb-2、 ARM状态与Thumb状态还有其他一些区别，这里我们没法全部介绍。比如，某些指令只在ARM状态下支持，而在Thumb状态下不可用，或者反之。要了解更多请参考ARM的官方文档。 ------------------------更新时间 2018-10-17 16:34 数据类型与寄存器 与高级语言类似，ARM也支持多种数据类型的运算，包括：8位（字节），16位（半字）、32位（字）和64位（双字）。 ARM的体系结构定义了16个32位通用寄存器，命名为R0~R15，实际开发中只用前13个作为通用寄存器（就像x86中的EAX、EBX等），最后三个有特殊的意义。 R13 用作栈指针(Stack Point, SP)，等价于 x86/64 下的 ESP、RSP 寄存器，指向程序栈的顶端 R14 用作连接寄存器（Link Register, SP），通常用于在函数调用中保存返回地址。某些指令会隐式的使用这个寄存器。比如，BL 总是在分支跳转到目标地址之前把返回值保存在 LR 中。x86/64 中总是把返回地址放在栈上，所以没有相应的寄存器。在不使用 LR 存储返回地址的代码中，这个寄存器可以作为通用寄存器。 R15 用作程序计数器（Program Counter，PC）。在 ARM 状态下执行的时候，PC 是当前指令的地址加 8（两条 ARM 指令之后）；在 Thumb 状态下，他是当前指令的地址加 4（两条 16 位 Thumb 指令后）。这个寄存器类似与 x86/64 下的 EIP/RIP，但后者总是指向下一条执行指令的地址。另外一个主要的区别在于，ARM 下代码可以直接读写 PC 寄存器，向 PC 寄存器写入一个值会导致运行立即从那个地址开始（参考下面代码片段）。 12340x00008344 push &#123;lr&#125;0x00008346 mov r0,pc0x00008348 mov.w r2, r2, ls1 #310x0000834C pop &#123;pc&#125; 在第 2 行执行之后，R0的值为0x0000834A(=0x00008346+4) 与其他体系结构类似，ARM把当前执行状态信息保存在当前程序状态寄存器（CPSR）中。从应用程序开发者的角度来看，CPSR类似于x86/x84下的EFLAGS/RFLAG寄存器。某些文档中会提到应用程序状态寄存器（APSR），这是CPSR中某些字段的别名。CPSR中有很多标志位，下面列出其中的部分： E(大小端标志位，Endianness bit)：ARM 可以运行在大端或小端模式下。这一位设置为 0 表示小端，1 表示大端。多数情况下使用小端，即为 0。 T(Thumb 标志位)：在 Thumb 状态下，这一位会设为 1；否则就是 ARM 状态。从 Thumb 到 ARM 或反向的状态切换的方式之一，就是修改这一标志位。 M(模式标志位， Mode Bit)：这几位指定当前的特权模式（USR、SVC 等）。 12 31 26 15 10 9 5 4 0CPSR |cond.flags | |1T |大小端标志位E | |Thumb标志位T |模式标志位M | ------------------------更新时间 2018-10-18 09:30 系统级控制与设置 ARM提供了协处理器的概念来支持额外的指令和系统级设置。举例来说，如果系统支持内存管理单元(MMU, Memory Management Unit)，那么内存管理单元的配置接口必须提供给启动代码或内核代码。在x86/x64上，这些设置接口是放在CR0和CR4中的；而在ARM上，则放在CP15中，ARM体系结构中有16个协处理器，编号为CP0~CP15.前 13 个协处理器时可选的或者是ARM保留的。制造商可以通过可选协处理器实现特定的指令或功能，每个协处理器提供了额外的“操作码”和寄存器，可以通过专门的ARM指令控制。举例来说，CP10和CP11常常用于调试和系统设置。而且CP15通常被称为系统控制协处理器，它保存着绝大多数系统设置（缓存、分页、异常等）。 1注意：NEON提供了单指令多数据（SIMD）指令集，通常用于多媒体应用程序。它与基于x86体系结构的SSE/MMX指令类似。 每个协处理器有16个寄存器和8个相应的操作码。这些寄存器和操作码的语义是特定于协处理器的。协处理器只能通过MRC(读)和MCR(写)指令访问，这两个指令接受协处理器编号、寄存器编号和操作码作为参数。举例来说，要读出转换基址寄存器(类似于x86/x64中的CR3)并保存到R0中，可以使用如下代码： 1MRC p15, 0, r0, c2, c0, 0 ; 保存到TTBR中 这句代码表示：“使用操作码0/0读出CP15的C2/C0，并保存结果到通用寄存器R0。”因为每个协处理器有很多寄存器和操作码，需要阅读文档才能确定其中每一个的精确含义。有些寄存器（C13/C0）是操作系统保留的，用于保存特定于进程或线程的数据。 MRC和MCR指令并不需要高特权级别才能运行（也就是说，可以在 USR 模式下执行），但有些协处理器寄存器和操作码只能在SVC模式下访问，如果没有足够的特权级别，该寄存器会导致异常。在实际的用户模式代码中很少看到这些指令，他们通常用在像ROM、bootloader、固件这样很底层的代码或内核模式代码中。 ------------------------更新时间 2018-10-21 13:10 指令集介绍 相比起x86体系结构，除了条件执行和桶式移位器，ARM 的指令集还有几点独特之处。首先，有些指令可以一次操作一系列寄存器。比如要把 5 个寄存器R6~R10保存到R1指向的一段内存位置，可以使用指令STM R1,&#123;R6-R10&#125;。R6会保存到内存地址R1，R7保存到R1+4，R8保存到R1+8，以此类推。对于不连续的寄存器，可以用逗号分隔（比如&#123;R1,R5,R8&#125;）。ARM的汇编语法中，寄存器范围通常用花括号表示。其次，有些指令在读写操作之后可能会更新基址寄存器，这通常通过在寄存器名后添加感叹号!来表示。举例来说，如果把前面的指令改写为STM R1!, &#123;R6-R10&#125;并执行，那么R1将会被更新为保存R10的地址之后的下一个地址。 ------------------------更新时间 2018-10-22 08:10 数据加载与存储 ARM是一种加载-存储式的体系结构，这意味着数据一定要加载到寄存器中才能操作。只有加载和存储指令能够访问内存，所有其他指令都只能操作寄存器。加载是指从内存中读入数据并保存到寄存器中的过程，存储则是指把寄存器的内容写入内存中的过程。在ARM体系结构中，加载和存储指令包括LDR/STR、LDM/STM和PUSH/POP。 LDR 与 STR LDR/STR指令比较基础的形式是，接受一个基址寄存器和一个偏移量作为参数。偏移量的表示有三种格式（立即数、寄存器、标量寄存器），每种格式有三种寻址形式。 第一种形式使用立即数作为偏移量。立即数就是一个整数。把这个数字与基址寄存器相加或相减，用于访问编译期偏移量可知的数据。立即数最常见的用途是访问结构或虚函数表中的某个特定字段。一般形式： STR Ra, [Rb, imm] LDR Ra, [Rc, imm] Rb是基址寄存器，imm是要加到Rb的偏移量 第二种偏移量格式用一个寄存器作为偏移量，通常用于访问数组中的元素，其索引值是运行时计算出的情况。其一般格式如下： STR Ra, [Rb, Rc] LDR Ra, [Rb, Rc] 根据上下文的不同，Rb或Rc可以是基址或偏移量。 第三种偏移量格式是使用标量寄存器作为偏移量。通常这种形式用在数组的迭代循环，而桶式移位器用于计算偏移量的步长。这种格式的一般形式如下： STR Ra, [Rb, Rc, &lt;shifter&gt;] LDR Ra, [Rb, Rc, &lt;shifter&gt;] Rb 是基址寄存器，Rc 是一个立即数，&lt;shifter&gt;是在立即数上执行的操作，他通常通过一个左移或右移操作对立即数进行成比例放大或缩小。 ------------------------更新时间 2018-10-23 07:30 LDR 的其他用途 LDR用于从内存向寄存器中加载数据，但有时候会看到这样的形式： 12301: DF F8 50 82 LDR.W R8, =0x2932E00 ; LDR R8, [PC, x]02: 80 4A LDR R2, =a04d ; &quot;%04d&quot; ; LDR R2, [PC, y]03: 0E 4B LDR R3, =__imp_realloc ; LDR R3, [PC, z] 伪指令内部使用了立即数寻址形式的LDR指令，PC作为基址寄存器。有时这也成为PC相对寻址（或在x64上称为RIP相对寻址）。ARM二进制文件通常有一个文本池（literal pool），这是某个字段中的一块内存区域，用于保存常量、字符串和用于提供位置无关索引支持的偏移量。（文本池是代码的一部分，所以在同一段中。）在前面的代码片段里，代码引用了保存在文本池中的一个32位常量、一个字符串和一个导入函数的偏移量。利用这种伪指令，可以只通过一个指令就把 32 位常量移入寄存器，因此它是很有用的。为了更清晰一点，下面给出一段代码示例： 1234501: .text:0100B134 35 4B LDR R3, =0x68DB8BAD; 实际上就是LDR R3, [PC, #0xD4]; 这时PC = 0x0100B13802: ...03: .text:0100B20C AD 8B DB 68 dword_100B20C DCD 0x68DB8BAD 因为代码处于Thumb状态，PC值是当前指令加上4，也就是0x0100B138。这里使用了立即数寻址方式，所以要读出位于0x0100B20C（=0x0100B138+0x4D）的字，这就是我们想要加载的常量。 ------------------------更新时间 2018-10-26 07:00 LDM 与 STM LDM和STM与LDR/STR类似，区别是前者可以从给定的基址寄存器加载多个字。LDM和STM通常用于从内存读出或写入多个数据块，通常语法为： 12LDM&lt;mode&gt; Rn[!], &#123;Rm&#125;STM&lt;mode&gt; Rn[!], &#123;Rm&#125; Rn是基址寄存器，其中保存要加载/存储的内存地址。！是可选的，意思是基址寄存器会更新为新的地址（写回）。Rm是要加载或存储的范围。LDM和STM有四种模式。 IA（后递增，Increment After）模式把数据存储到基址寄存器指定的内存位置。如果有写回的话，就写回最后一个地址加 4 字节的地址。如果没有指定的话，这是默认使用的模式。 IB（前递增，Increment Before）模式把数据存储在基址寄存器加 4 的地址上。如果有写会的话，就把最后地址写回。 DA（后递减，Decrement After）模式保存数据使得最后的地址是基地址。如果有写回的话，就把最低地址减 4 写回。 DB（前递减，Decrement Before）模式存储数据使得最后的地址是基地址减 4.如果有写回的话，就把最低地址写回。 下面是调试器观察的实例： 123456789101112131415161718192021222324252627282930(gdb) br mainBreakpoint 1 at 0x8344(gdb) disas mainDump of assembler code for function main:0x00008344 &lt;+0&gt;: ldr r6, =mem ; 稍有修改0x00008348 &lt;+4&gt;: mov r0, #100x0000834c &lt;+8&gt;: mov r1, #110x00008350 &lt;+12&gt;: mov r2, #120x00008354 &lt;+16&gt;: ldm r6, &#123;r3,r4,r5&#125; ; IA模式0x00008358 &lt;+20&gt;: stm r6, &#123;r0,r1,r2&#125; ; IA模式...(gdb) rBreakpoint 1, 0x00008344 in main ()(gdb) si0x00008348 in main ()(gdb) x/3x $r60x105c &lt;mem&gt;: 0x00000001 0x00000002 0x00000003(gdb) si0x0000834c in main ()...(gdb)0x00008358 in main ()(gdb) info reg r3 r4 r5r3 0x1 1r4 0x2 2r5 0x3 3(gdb) si0x0000835c in main ()(gdb) x/3x $r60x1050c &lt;mem&gt;: 0x0000000a 0x0000000b 0x0000000c 第 5 行把一个内存地址写入R6，这个内存地址（0x1050c）的内容是一个 3 字数据（第 17 行）。6-8 行将R2～R0设置为某个常量。第 9 行加载从R6指向的内存地址开始的 3 个字到R3～R5。如第 24 ～ 26 行所示，R3～R5的内容正是期望值。第 10 行存储R0~R2到R6指向的内存地址开始的空间。第 29 行显示了期望的写入值。下图展示前面的操作结果。 123456789101112131415161718192021222324252627282930 mem|---|| 0x1 | | | ldr r6, =mem || --- ||| mov r0, #10| 0x2 | | | mov r1, #11 || --- ||| mov r2, #12| 0x3 | | | ldm r6, &#123;r3,r4,r5&#125; || --- |\\/|---|| 0x1 | r6 | | stm r6, &#123;r0,r1,r2&#125; || --- |||| 0x2 | r6+4 | || --- |||| 0x3 | r6+8 | || --- |\\/r0=a r1=b r2=cr3=1 r4=2 r5=3|---|| 0xA | r6 || --- || 0xB | r6+4 || --- || 0xC | r6+8 || --- |r0=a r1=b r2=cr3=1 r4=2 r5=3 下面用写回模式做同样的实验： 123456789101112131415161718192021222324252627282930(gdb) br mainBreakpoint 1 at 0x8344(gdb) disaa mainDump of assembler code for function main:0x00008344 &lt;+0&gt;: ldr r6, =mem ; 稍有修改0x00008348 &lt;+4&gt;: mov r0, #100x0000834c &lt;+8&gt;: mov r1, #110x00008350 &lt;+12&gt;:mov r2, #120x00008354 &lt;+16&gt;:ldm r6!, &#123;r3, r4, r5&#125; ; IA带写回模式0x00008358 &lt;+20&gt;:stmia r6!, &#123;r0, r1, r2&#125; ; IA带写回模式...(gdb) rBreakpoint 1, 0x0008344 in main ()(gdb) si0x00008348 in main ()...(gdb)0x00008354 in main ()(gdb) x/3x $r60x1050c &lt;mem&gt;： 0x000001 0x00000002 0x00000003(gdb) si0x00008358 in main ()(gdb) info reg r6r6 0x10518 66840(gdb) si0x0000835c in main ()(gdb) info reg $r6r6 0x10524 66852(gdb) x/4x $r6-120x10518 : 0x0000000a 0x0000000b 0x0000000c 0x00000000 第 9 行使用IA写回模式，所以R6更新为最后地址加 4 的值（第 23 行）。第 10 行、27 行和 30 行可以看到同样的模式。下图展示了实验代码片段执行的结果： 12345678910111213141516171819202122232425262728293031323334 mem|---|| 0x1 | 0x1050c | | ldr r6, =mem || --- ||| mov r0, #10| 0x2 | 0x1050c+4 | | mov r1, #11 || --- ||| mov r2, #12| 0x3 | 0x1050c+8 | | ldm r6!, &#123;r3,r4,r5&#125; || --- |0x1050c+c \\/|---|| 0x1 | 0x1050c | | stm r6, &#123;r0,r1,r2&#125; || --- |||| 0x2 | 0x1050c+4 | || --- |||| 0x3 | 0x1050c+8 | || --- |0x1050c+c r6 \\/r0=a r1=b r2=cr3=1 r4=2 r5=3|---|| 0x1 | 0x1050c || --- || 0x2 | 0x1050c+4 || --- || 0x3 | 0x1050c+8 || --- || 0xA | 0x1050c+c || --- || 0xB | 0x1050c+10 || --- || 0xC | 0x1050c+14 || --- | 0x1050c+18 r6 | LDM和STM指令可以一次写入多个字，所以通常用于块复制和块移动操作。比如有时用这些指令来执行编译时复制长度已知的内联memcpy。这类似于x86中带有REP前缀的movs指令。 注意 STM/LDM后面经常会出现后缀FD、FA、ED或EA。它们就是不同模式下（IA/IB等）的STM/LDM指令的伪指令，分别对应于STMFD/STMDB、STMFA/STMIB、STMED/STMDA、STMEA/STMIA、LDMFD/LDMIA、LDMFA/LDMDA和LDMEA/LDMDB。因为这些对应关系太难记忆，建议为每个指令画一个图。 ------------------------更新时间 2018-11-4 08:00 PUSH 与 POP 加载/存储指令的最后一组是PUSH和POP。他们类似于LDM/STM，但有两点不同： 他们隐式地使用 SP 作为基地址； SP 会自动更新。 和x86/x64中的一样，栈是朝下向低地址方向增长的。通用的语法是PUSH/POP &#123;Rn&#125;,其中Rn可以是一个寄存器范围。 PUSH指令把一个或多个寄存器保存在栈中，使得最后一个的位置位于当前栈指针向下 4 字节处，然后把SP更新为第一个位置的地址。POP从当前栈指针处开始向寄存器加载数据，然后更新SP为最后一个位置的地址的向上 4 字节处。PUSH/POP实际上就是以SP作为基地址指针的带写回的STMDB/LDMIA。 最常用到PUSH/POP的地方就是在函数的起始和结束处，在这里他们被用作函数序言和尾声（就像ARM状态下的STMFD/LDMFD一样）。举例来说： 1232D E9 F0 4F PUSH.W &#123;R4-R11, LR&#125; ; 保存寄存器和返回地址...BD E9 F0 8F POP.W &#123;R4-R11, PC&#125; ; 恢复寄存器值并返回 ------------------------更新时间 2018-11-5 07:00 函数与函数调用 x86/x64只有一个用于函数调用的指令（CALL）和一个用于分支跳转的指令（JMP）。与之不同，根据目标地址的编码方式，ARM 则提供了多种指令。调用函数的时候，处理器需要知道函数返回后从哪里继续执行，这个位置通常被称为返回地址。在x86中，CALL指令在跳转到目标函数之前隐式地把返回地址压入栈顶，等到目标函数执行完毕，会把栈顶弹出到EIP，从而从返回地址恢复执行。 ARM体系结构上的机制本质上也是如此，只有几点微小的区别。首先，返回地址可以保存在栈上，也可以保存在链接寄存器（LR）中；调用结束后要恢复执行，需要显式地把返回地址从栈上弹出到PC寄存器，否则会无条件跳转到LR。其次，根据目标地址的最低位（LSB）不同，一次分支跳转可以在ARM状态和Thumb状态之间切换。第三点，ARM定义了标准调用惯例：前 4 个 32 位参数通过寄存器（R0-R3）传递，其余的参数放在栈上。返回值保存在R0中。 ARM中函数调用的指令是B、BX、BL和BLX。 尽管在函数调用的上下文中很少看到B指令，但这条指令确实可以用于控制传递。他就是一条简单的无条件跳转指令，于x86中的JMP指令相同，通常在循环和条件执行内部用于跳转到开头或跳出循环，还可以用于调用永不返回的函数。 B指令只能使用标签偏移量作为其目标地址，而不能使用寄存器。在这种情况下，B指令的语法为B imm，其中imm是相对于当前指令的偏移量。（这里没有考虑条件执行标志位，将会在之后的笔记中详细介绍。）需要记住的是：因为ARM和Thumb指令是2字节或4字节对齐的，所以目标偏移量必须是一个偶数。 BX是分支跳转并交换（Branch and Exchange）。与B指令的相似之处在于，两者都是把控制转移到某个目标地址处，但BX能够在ARM和Thumb状态间切换，并且目标地址是保存在寄存器中的。分支跳转指令以X结尾，表示这条指令能切换状态。如果目标地址最低位是 1，那么处理器会自动切换到Thumb状态，否则就执行在ARM状态。指令的格式是BX&lt;寄存器&gt;，其中寄存器中存有目标地址。这条指令有两种最常用的方式，一种是通过跳转到LR（也即 BX LR）从函数返回，还有一种是用于切换到不同状态的代码（也即从ARM切换到Thumb状态或反之）。在编译后的代码中，函数结尾处几乎总会出现BX LR，基本上于x86中的RET相同。 BL是分支跳转并连接（Branch with Link），它类似于B指令，但他可以在把控制切换到目标偏移量之前把返回地址保存到LR。这也许是和x86中的CALL指令最为接近的一条指令，经常在函数调用中使用。BL指令格式与B指令相同（也就是说，只接受偏移量参数）。下面这段代码解释了函数调用和返回的过程： 1234567800014350 BL foo ; LR = 0x0001435400014354 MOVS R4, #0x15...0001B224 foo0001B224 PUSH &#123;R1-R3&#125;0001B226 MOV R3, 0x6124...0001B24C BX LR ; 返回到0x00014354 上面代码的第 1 行使用BL调用函数foo。在转换控制到目标之前，BL在LR中保存了返回地址（0x000014354）。foo做了一些工作然后返回到调用者（BX LR）。 BLX是指跳转加连接和交换（Branch with Link and Exchange）。于BL类似，BLX也可以支持状态切换。两者主要的区别在于，BLX可以接受偏移量或寄存器作为跳转目标，而且在BLX指令使用偏移量的情况下，处理器总是会切换状态（ARM到Thumb或反之）。因为这条指令于BL的特性相同，也可以把它当做x86中的CALL指令。实际使用中，BL和BLX都用于实现函数调用。如果函数在32MB范围之内，通常使用BL，而目标区域不确定（比如函数指针）的时候常用BLX。通常在Thumb状态下运行的时候，使用BLX指令调用库例程，而在ARM状态下使用BL。 ------------------------更新时间 2018-11-9 07:00 算术运算 把数值从内存加载到寄存器之后，代码就可以上面执行各种操作了。最简单的操作就是通过mov指令把数据移动到另一个寄存器中。操作源可以是常量、寄存器或桶式移位器的运算结果。桶式移位器运算包括左移（LSL）、右移（LSR、ASR）和循环移位（ROR、RRX）。桶式移位器让指令可以操作无法以立即数形式编码的常量，因此很有用处。ARM和Thumb指令的宽度可能是16位或32位，所以无法直接使用32位常数作为参数。有了桶式移位器，立即数可以被转换为一个更大值然后移动到其他寄存器。另一种移动32位常量到寄存器的方法是把常量分割为两个16位数值，分两次移动；这通常通过MOVW和MOVT指令实现。MOVT设置寄存器的高16位，MOVW设置低16位。 基本算术和逻辑运算包括ADD、SUB、MUL、AND、ORR和EOR。 注意：ARM没有原生的除法指令。（ARMv7-R和ARMv7-M内核有SDIV和UDIV指令，但这里不讨论）实际应用中，运行时会使用软件实现来进行除法运算，代码只要按需调用。下面是Windows C运行时的一个例子： 12341 46 MOV R1， R840 46 MOV R0,R635 F0 9E 9F BL __rt_udiv ; udiv的软件实现 ------------------------更新时间 2018-11-11 07:00 分支跳转与条件执行 前面讨论的都是按照线性顺序执行的例子，而绝大多数程序都包含有条件与循环。在汇编代码层级，这些结构是通过存储在应用程序状态寄存器（APSR）中的条件标志位实现的。APSR是CPSR的别名，类似于x86中的EFLAG寄存器。 N（Negative，负值标志位）：如果运算的结果是负数，这个标志就会被设置（结果的最高有效位为 1） Z（Zero，零标志位）：运算结果为 0 时设置 C（Carry，借位标志位）：两个无符号值计算结果溢出时设置 V（Overflow，溢出标志位）：两个有符号值计算结果溢出时设置 IT（If-then 标志位）：这些标志位编码了 Thumb 指令 IT 使用的各种条件。 1234567 31 26 15 10 9 5 4 0CPSR |cond.flags | |1T |大小端标志位E | |Thumb标志位T |模式标志位M |...APSR |N|Z|C|V|Q | |保留| 31 26 15 0 N、Z、C 和 V 标志位与 x86 中的 EFLAG 寄存器的 SF、ZF、CF 和 OF 标志位相同。在更高级的语言中，使用这些标志位来实现条件和循环；在指令级代码中，也通过这些标志位支持条件执行。通过这些标志位来描述相等性。 后缀/编码 意义 标志位 EQ 等于 Z==1 NE 不等于 Z==0 MI 减、负 N==1 PL 加、正或者为 0 N==0 HI 无符号大于 C1 且 Z0 LS 无符号小于 C0 或 Z1 GE 有符号大于等于 N==V LT 有符号小于 N！=V GT 有符号大于 Z0 且 NV LE 有符号小于等于 Z==1 或 N！=V 默认情况下指令不会更新条件标志位，除非使用了 S 后缀。比较指令（CBZ、CMP、TST、CMN 和 TEO）会自动更新标志位，因为通常他们被用于分支指令之前。 最常用的比较指令可能就是 CMP。其语法为 CMP Rn, X，其中 Rn 是寄存器，X 可以是立即数、寄存器或桶式移位操作。其语义与 x86 中的同名指令相同：执行 Rn - X，设置相应的标志位，然后丢弃结果。通常这条指令后面会跟随一个条件分支跳转。下面是一个用法示例及其伪代码： ARM 123456789101112B3 EB E7 7F CMP.W R3, R7, ASR #3105 DB BLT loc_less01 DC BGT loc_greaterBD 42 CMP R5, R702 D9 BLS loc_less loc_greater07 3D SUBS R5, #76E F1 00 0E SBC.W LR, LR, #0 loc_lessA5 FB 08 12 UMULL.W R1, R2, R5, R887 FB 08 04 SMULL.W R0, R4, R7, R80E FB 08 23 MLA.W R3, LR, R8, R2 C 伪代码 123if (r3 &lt; r7) &#123;goto loc_less;&#125; else if (r3 &gt; r7) &#123;goto loc_greater;&#125; else if (r5 &lt; r7) &#123;goto loc_less;&#125; ------------------------更新时间 2018-11-12 07:00 Thunb 状态 switch-case 杂项 Windows 内核 调试与自动化 代码混淆 代码研究 windows 内核代码 片段 1： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980; NTSTATUS __cdecl sub_4038f0(PFILE_OBJECT FileObject, HANDLE Handle, BOOLEAN flag)sub_4038F0 proc nearpush rbx ; rbx压栈push rbp ; rbp压栈push rsi ; rsi压栈push rdi ; rdi压栈push r12 ; r12压栈sub rsp, 60h ; rsp的值减去0x60mov bpl, r8b ; r8p的值入bplmov r12, rdx ; 将rdx的值放进栈r12中mov rdi, rcx ; 将rcx的值放进栈rdi中mov cs:IoGetRelatedDeviceObject ; IoGetRelatedDeviceObject返回值指向相应设备对象的指针mov [rsp+88h+arg_18], 1 ; 把1赋给[rsp+88h+arg_18]xor edx, edx ; ChargeQuota 将edx初始化置0mov cl, [rax+4ch] ; StackSize 栈空间大小mov rsi, rax ; 将rax的值放进栈rsi中call cs:IoAllocateIrp ; IoAllocateIrp例程分配一个IRP（为每个驱动层下的调用者给定I/O堆栈数量和选项）test rax, rax ; 相当于and rax rax，根据结果设置标志位，不会保存结果。（影响标志位C,O,P,Z,S。其中C与O两个标志会被设为0）mov rbx, rax ; 将rax的值放进栈rbx中jnz short loc_403932 ; 如果Z标志位为0，就跳转到loc_403932中mov eax, 0C0000017h ; 把立即数0C0000017h放进eax（此处用来表示跳转失败）。立即数必须以数开头，以字母开头会被认为是寄存器或变量。jmp loc_403A0C ; 无条件跳转到 loc_403A0C方法（loc_403A0C方法的作用是清理栈空间）loc_403932:lea rax, [rsp+88h+arg_18] ; rax获取[rsp+88h+arg_18]的地址xor r8d, r8d ; State 状态值初始化为0lea rcx, [rsp+88h+Event] ; Event rcx获取[rsp+88h+Event]的地址mov [rbx+18h], rax ; IRP.AssociatedIrp.SystemBuffer 把rax所指向地址的值赋给[rbx+18h]，也就是把1赋给[rbx+18h]lea rax, [rsp+88h+Event] ; rax获取[rsp+88h+Event]的地址lea edx, [r8+1] ; Type 类型 edx获取[r8+1]的地址mov [rbx+50h], rax ; IRP.UserEvent 把rax所指向[rsp+88h+Event]地址的值赋给[rbx+50h]，作为用户事件lea rax, [rsp+88h+var_58] ; rax获取[rsp+88h+var_58]的地址mov [rbx+48h], rax ; IRP.UserIosb 把rax所指向[rsp+88h+var_58]地址的值赋给[rbx+48h]mov rax, gs:+188h ; KPCR.Prcb.CurrentThread gs寄存器基址+18h得到的地址处的值，赋给raxmov [rbx+0C0h], rdi ; IRP.Tail.OVerlay.OriginalFileObiect 把寄存器rdi的值（也就是前面rcx的值）放进内存[rbx+48h]中mov [rbx+98h], rax ; IRP.Tail.Overlay.Thread gs寄存器基址+18h处的值放进内存[rbx+98h]mov byte ptr [rbx+40h], 0 ; IRP.RequestorMode 把[rbx+40h]处的一个字节填为0call cs:KeInitializeEvent ; 调用 KeInitializeEvent方法将一个事件对象初始化为一个同步或通知类型的事件，并且设置为一个有信号或无信号的状态test bpl, bpl ; and bpl bpl，根据结果设置标志位，不会保存结果。C与O会被设置为0.mov rcx, [rbx+0B8h] ; 将内存[rbx+0B8h]处的值放进rcx中mov byte ptr [rbx+40h], 6 ; IRP_MJ_SET_INFORMATION 把[rbx+40h]处的一个字节填为6mov [rcx-20h], rsi ; IO_STACK_LOCATION.DeviceObject 将rsi处的值放进内存[rcx-20h]中mov [rcx-18h], rdi ; IO_STACK_LOCATION.FileObject 将rdi处的值放进内存[rcx-18h]中jz short loc_4039A6 ; 如果Z标志位为1，就跳转到loc_4039A6中mov rax, [rdi+28h] ; FILE_OBJECT.SectionObjectPointer 将内存[rdi+28h]中的值放进rax中test rax, rax ; and rax rax，根据结果设置标志位，不会保存结果。C与O会被设置为0.jz short loc_4039A6 ; 如果Z标志位为1，就跳转到loc_4039A6中mov [rax+10h], 0 ; SECTION_OBJECT_POINTERS.ImageSectionObject 将[rax+10h]置为0loc_4039A6:mov [rcx-28h], r12 ; IO_STACK_LOCATION.Parameters.SetFile.DeleteHandle 将寄存器r12中的值放进[rcx-28h]中mov [rcx-30h], rdi ; IO_STACK_LOCATION.Parameters.SetFile.Object 将寄存器rdi中的值放进[rcx-30h]中mov dword ptr [rcx-38h], 0Dh ; FileDispositionInformation IO_STACK_LOCATION.Parameters.SetFile.FileInfomationClass 将[rcx-38h]处的双字设置为0Dhmov dword ptr [rcx-40h],1 ; IO_STACK_LOCATION.Parameters.SetFile.Length 将[rcx-40h]处的双字设置为1mov rax, [rbx+0b8h] ; CurrentIrpStackLocation 将[rbx+0b8h]处的值放进rax中lea rcx, sub_4038B4 ; completionroutine rcx获取sub_4038B4的地址mov [rax-10h], rcx ; IO_STACK_LOCATION.ComplerionRoutine 将rcx指向sub_4038B4的地址处的值放进[rax-10h]中mov rcx, rsi ; DeviceObject 将rsi处的值放进rcx中mov rdx, rbx ; Irp 将rbx处的值放进rdx中mov qword ptr [rax-8], 0 ; 将内存[rax-8]处的双字设置为0mov byte ptr [rax-45h], 0E0h ; flag 将内存[rax-45h]处的一个字节设置为0call cs:IofCallDriver ; 调用IofCallDriver方法cmp eax, 103h ; STATUS_PENDING 比较eax和103hjnz short loc_403A09 ; 如果eax和103h不相等就跳转到loc_403A09lea rcx, [rsp+88h+Event] ; Object rcx获取[rsp+88h+Event]的地址mov r9b, 1 ; Alertable 将r9b赋值为1xor r8d, r8d ; WaitMode r8d置为0xor edx, edx ; WaitReason edx置为0mov [rsp+88h+var_68], 0 ; 将[rsp+88h+var_68]置为0call cs:KeWaitForSingleObject ; 调用该方法将当前线程(ethread里以Wait开头的字段WaitIrql,WaitMode,WaitStatus)置为等待状态,直到提供的分发机器对象被置为已处理状态或第五个参数给出的Timeout走完。loc_403A09:mov eax, [rbx+30h] ; IRP.IoStatus.Status 将内存[rbx+30h]处的值赋给eaxloc_403A0C: ; 清理栈add rsp, 60h ; 栈指针rsp+60h进行复位pop r12 ; 出栈r12pop rdi ; 出栈rdipop rsi ; 出栈rsipop rbp ; 出栈rbppop rbx ; 出栈rbxretnsub_4038F0 endp","categories":[{"name":"安全","slug":"安全","permalink":"http://debug.cool/categories/%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://debug.cool/tags/%E7%AC%94%E8%AE%B0/"},{"name":"逆向","slug":"逆向","permalink":"http://debug.cool/tags/%E9%80%86%E5%90%91/"},{"name":"汇编","slug":"汇编","permalink":"http://debug.cool/tags/%E6%B1%87%E7%BC%96/"},{"name":"网络安全","slug":"网络安全","permalink":"http://debug.cool/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"如何编写一个简单内核","slug":"devKernelProgram","date":"2018-09-04T06:04:00.000Z","updated":"2022-11-15T14:31:21.093Z","comments":true,"path":"2018/09/04/devKernelProgram/","link":"","permalink":"http://debug.cool/2018/09/04/devKernelProgram/","excerpt":"编写一个简单的内核，可以再 x86 系统上加载 GRUB 引导加载程序。此内核将在屏幕上显示一条信息，然后挂起。","text":"编写一个简单的内核，可以再 x86 系统上加载 GRUB 引导加载程序。此内核将在屏幕上显示一条信息，然后挂起。 x86 机器是如何启动的 在我们考虑编写内核之前，让我们看看机器是如何启动并将控制转移到内核的。 上电后，x86 CPU的大多数寄存器都有明确定义的值。指令指针（EIP）寄存器保存处理器正在执行的指令的存储器地址。EIP硬编码为值0xFFFFFFF0，因此，x86 CPU硬连线开始在物理地址0xFFFFFFF0处执行。实际上，它是32位地址空间的最后16个字节。该存储器地址称为复位向量。 现在，芯片组的内存映射确保0xFFFFFFF0映射到BIOS的某个部分，而不是RAM。同时，BIOS将自身复制到RAM以便更快地访问，我们称之为shadowing。地址0xFFFFFFF0只包含一条跳转指令，指向BIOS复制自身的内存中的地址。 到这里，BIOS代码开始执行。BIOS首先按配置的引导设备顺序搜索可引导设备。它会检查某个幻数以确定设备是否可引导（第一扇区的字节 511 和 512 是否为0xAA55）。 一旦BIOS找到可引导设备，它就会从物理地址0x7c00开始将设备第一个扇区的内容复制到RAM中，然后跳转到地址并执行刚刚加载的代码，此代码称为引导加载程序。 然后，引导加载程序将内核加载到物理地址0x100000。地址0x100000用作x86计算机上所有大内核的起始地址。 所有x86处理器都以简单的16位模式开始，称为实模式。GRUB引导加载程序通过将CR0寄存器的最低位设置为1来切换到32位保护模式，因此，内核以32位保护模式加载。 请注意，在Linux内核的情况下，GRUB会检测Linux启动协议并以实模式加载Linux内核。Linux内核本身可以切换到保护模式。 我们需要什么 一台 x86 电脑 Linux NASM 汇编程序 gcc ld（GNU 链接器） grub 源代码 源代码可以在 Github 存储库中找到mkernel 使用程序集的入口点 我们喜欢用 C 语言编写所有内容，但我们无法避免一些组装。我们将用x86汇编语言编写一个小文件，以此来作为我们内核的起点。我们所有的汇编文件都会调用一个外部函数，我们将用 C 编写，然后暂停程序流程。 我们如何确保此汇编代码将作为内核的起点呢？ 我们将使用链接脚本来链接目标文件以生成最终的内核可执行文件（稍后将详细解释）。在此链接描述文件中，我们将明确指定我们希望将二进制文件加载到地址0x100000。正如我之前所说，这个地址是内核的预期。因此，引导加载程序将负责触发内核的入口点。 这是汇编代码： 12345678910111213141516171819202122232425;;kernel.asmbits 32 ;nasm directive - 32 bitsection .textglobal startextern kmain ;kmain is defined in the c filestart: cli ;block interrupts mov esp, stack_space ;set stack pointer call kmain hlt ;halt the CPUsection .bssresb 8192 ;8KB for stackstack_space: 第一条指令bits 32不是x86汇编指令，它是NASM汇编程序的一个指令，它指定它应该生成代码，以在32位模式下运行的处理器上运行。在我们的例子中，它并不是强制性的，但是这里包含了它，因为它确实是一个良好实践。 第二行开始文本部分（又名代码部分），这是我们放置所有代码的地方。 global是另一个将源代码中的符号设置为全局的NASM指令，通过这样做，链接器知道符号的start位置，这恰好是我们的切入点。 kmain是我们的函数，将在我们的kernel.c文件中定义。extern声明该函数在其他地方声明。 然后，我们有了start函数，它调用kmain函数并使用hlt指令暂停CPU。中断可以从hlt指令中唤醒CPU，所以我们事先使用cli指令禁用中断。cli是明显中断的缩写。 理想情况下，我们应该为堆栈留出一些内存并将堆栈指针（esp）指向它。但是，似乎GRUB这样做就已经设置了堆栈指针。但是，为了以防万一，我们将在BSS部分中分配一些空间，并将堆栈指针指向分配的内存的开头。我们使用resb以字节为单位保留内存的指令，在它之后，留下一个标签，指向保留的内存块的边缘。在kmain调用之前，堆栈指针（esp）使用mov指令使指向该空间。 C 中的内核 在kernel.asm，我们调用了该函数kmain()。所以我们的C代码将开始执行kmain()： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/* * kernel.c */void kmain(void) &#123; const char *str = &quot;my first kernel&quot;; char *vidptr = (char*)0xb8000; //video mem begins here. unsigned int i = 0; unsigned int j = 0; /* this loops clears the screen * there are 25 lines each of 80 columns; each element takes 2 bytes */ while(j &lt; 80 * 25 * 2) &#123; /* blank character */ vidptr[j] = &#x27; &#x27;; /* attribute-byte - light grey on black screen */ vidptr[j+1] = 0x07; j = j + 2; &#125; j = 0; /* this loop writes the string to video memory */ while(str[j] != &#x27;\\0&#x27;) &#123; /* the character&#x27;s ascii */ vidptr[i] = str[j]; /* attribute-byte: give character black bg and light grey fg */ vidptr[i+1] = 0x07; ++j; i = i + 2; &#125; return;&#125; 我们所有的内核都会清除屏幕并写入字符串“我的第一个内核”。 首先，我们创建一个指向vidptr地址0xb8000的指针，该地址是受保护模式下的视频内存的开始。屏幕的文本内存只是我们地址空间中的一块内存，屏幕的内存映射输入/输出从0xb8000开始，支持25行，每行包含80个ASCII字符。 该文本存储器中的每个字符元素由16位（2字节）表示，而不是我们习惯的8位（1字节）。第一个字节应该具有ASCII中的字符表示，第二个字节是attribute-byte。这描述了其特征属性，比如说颜色。 如果要s在黑色背景上打印绿色字符，我们只需要将字符s存储在视频存储器地址的第一个字节中，将值0x02存储在第二个字节中即可。0代表黑色背景，2代表绿色前景。 请查看下表中的不同颜色： 123456789101112131415160 - Black,1 - Blue,2 - Green,3 - Cyan,4 - Red,5 - Magenta,6 - Brown,7 - Light Grey,8 - Dark Grey,9 - Light Blue,10/a - Light Green,11/b - Light Cyan,12/c - Light Red,13/d - Light Magenta,14/e - Light Brown,15/f – White. 在我们的内核中，我们将在黑色背景上使用浅灰色字符，所以我们的属性字节必须具有值0x07。 在第一个while循环中，程序在 25 行的 80 列中写入具有0x07属性的空白字符，这样就可以清除屏幕。 在第二个while循环中，空终止字符串“my first kernel”的字符被写入视频内存块，每个字符保存一个0x07的属性字节。 这将会在屏幕上显示字符串。 链接部分 我们将kernel.asm与NASM组装成一个目标文件，然后使用GCC，将kernel.c编译成另一个目标文件。现在，我们的工作是将这些对象链接到可执行的可引导内核。 为此，我们使用显式链接脚本，它可以作为参数传递给ld（我们的链接器）。 123456789101112131415161718192021/* * link.ld */OUTPUT_FORMAT(elf32-i386)ENTRY(start)SECTIONS &#123; . = 0x100000; .text : &#123; *(.text) &#125; .data : &#123; *(.data) &#125; .bss : &#123; *(.bss) &#125;&#125; 首先，我们将输出可执行文件的输出格式设置为32位可执行文件和可链接格式（ELF）。ELF 是x86架构上类Unix系统的标准二进制文件格式。 ENTRY有一个论点，它指定应该是我们的可执行文件的入口点的符号名称。 SECTIONS是我们最重要的部分，在这里，我们定义可执行文件的布局。我们可以指定如何合并不同的部分以及每个部分的放置位置。 在SECTIONS语句后面的大括号内，句点字符（.）表示位置计数器。 在SECTIONS块的开头，位置计数器始终初始化为0x0，这可以通过为其分配新值来修改它。 记住前文中说过的，内核的代码应该从地址0x100000开始，所以我们将位置计数器设置为0x100000。 看看下一行.text：&#123;*（.text）&#125; 星号（*）是一个匹配任何文件名的通配符，因此，表达式*(.text)表示.text来自所有输入文件的所有输入节。 因此，链接器将目标文件的所有文本部分，合并到位置计数器中存储地址的可执行文件部分，所以我们的可执行文件的代码部分从0x100000开始。 链接器放置文本输出节之后，位置计数器的值将变为0x1000000 +文本输出节的大小。 类似的，数据和bss部分被合并并放置在location-counter的then值处。 Grub 和 Multiboot 现在，我们准备好构建内核的所有文件。但是，既然我们想用GRUB引导程序引导我们的内核，那么还有一步。 有一个使用引导加载程序加载各种x86内核的标准，称为Multiboot spec（多重引导规范）。 如果GRUB符合Multiboot规范，它将只加载我们的内核。 根据规范，内核必须在其前8个千字节内包含一个头，称为Multiboot header（多引导头）。 此外，此Multiboot标头必须包含3个字节，即 4 字节对齐，即： 一个魔术字段（magic field）：包含幻数0x1BADB002，以识别头部。 一个标志字段（flags field）：我们不关心这个字段，只需将其设置为零。 一个校验字段（checksum field）：添加“magic”和“flags”的校验字段必须为零。 所以我们的kernel.asm就会变成： 12345678910111213141516171819202122232425262728293031323334353637;;kernel.asm;nasm directive - 32 bitbits 32section .text ;multiboot spec align 4 dd 0x1BADB002 ;magic dd 0x00 ;flags dd - (0x1BADB002 + 0x00) ;checksum. m+f+c should be zeroglobal startextern kmain ;kmain is defined in the c filestart: cli ;block interrupts mov esp, stack_space ;set stack pointer call kmain hlt ;halt the CPUsection .bssresb 8192 ;8KB for stackstack_space: DD定义大小为 4 个字节的双字。 构建内核 现在，我们将创建从目标文件kernel.asm和kernel.c，然后使用我们的链接脚本链接。 1nasm -f elf32 kernel.asm -o kasm.o 将运行汇编程序以ELF-32位格式创建目标文件kasm.o。 1gcc -m32 -c kernel.c -o kc.o '-c'选项确保在编译之后，链接不会隐式发生。 1ld -m elf_i386 -T link.ld -o kernel kasm.o kc.o 将使用我们的链接描述文件运行链接器并生成名为kernel的可执行文件。 配置你的 grub 并运行你的内核 GRUB要求您的内核具有名称模式kernel-&lt;version&gt;，所以，我们需要重命名内核。我将内核可执行文件重命名为kernel-701。 现在将它放在/ boot目录中。（需要超级用户权限才能执行此操作。） 在GRUB配置文件中，grub.cfg应该添加一个条目，例如： 1title myKernelroot (hd0,0)kernel /boot/kernel-701 ro 不要忘记删除指令hiddenmenu（如果存在的话）。 重新启动计算机，你将获得列出内核名称的列表选择。 那就是你的内核!! PS 始终建议给自己设置一个虚拟机，用于各种内核黑客攻击。 要在grub2 上运行它，这是新发行版的默认引导加载程序，你的配置应如下所示： 1menuentry &#x27;kernel 701&#x27; &#123;set root=&#x27;hd0,msdos1&#x27;multiboot /boot/kernel-701 ro&#125; 此外，如果您想在 qemu 模拟器上运行内核而不是使用 GRUB 启动内核，你可以通过以下方式执行此操作： 1qemu-system-i386 -kernel kernel 参考和感谢 arjun024 的源码及思路 wiki.osdev.org osdever.net Multiboot spec","categories":[{"name":"研发","slug":"研发","permalink":"http://debug.cool/categories/%E7%A0%94%E5%8F%91/"}],"tags":[{"name":"研发","slug":"研发","permalink":"http://debug.cool/tags/%E7%A0%94%E5%8F%91/"},{"name":"笔记","slug":"笔记","permalink":"http://debug.cool/tags/%E7%AC%94%E8%AE%B0/"},{"name":"内核","slug":"内核","permalink":"http://debug.cool/tags/%E5%86%85%E6%A0%B8/"}]},{"title":"如何判断员工持股计划是否靠谱","slug":"stocksCom","date":"2018-03-25T16:10:00.000Z","updated":"2022-11-15T14:35:43.470Z","comments":true,"path":"2018/03/26/stocksCom/","link":"","permalink":"http://debug.cool/2018/03/26/stocksCom/","excerpt":"公司的本意是希望公司发展好，员工多赚钱，但其中也不乏很多公司都是在发展不顺、股票大幅下跌等情况下，为了稳定人心、稳住股价，推出员工持股计划。","text":"公司的本意是希望公司发展好，员工多赚钱，但其中也不乏很多公司都是在发展不顺、股票大幅下跌等情况下，为了稳定人心、稳住股价，推出员工持股计划。 这样不确定因素太多，容易成为接盘侠。目前员工持股绝大部分是亏的（数据可以自己搜一下，从股市、工商信息这几个官方渠道去搜），不要只盯着那几家发展好的公司，用幸存者偏差去看待员工持股这件事，要看全盘数据案例。 首先，员工持股计划是通过二级市场买入，如果你看好公司未来前景，完全可以自己买，无需通过公司的员工持股计划买入。 当行情不好的时候你自主购买的股票可以随时卖出止损，员工持股是做不到的，员工持股一般是统一管理和操作。，当公司的员工持股计划亏50%以上，算上1:1的杠杆实际上本金早就没了。 公司为什么热衷于员工持股？ 给广大投资者以信心炒高股价； 股价高质押股票可以融到更多的钱； 稳定公司人员，股票赚了皆大欢喜你不会走，股票亏了你等着公司兜底更不会走（一般员工持股老板都会明示或暗示兜底） 那么，问题来了，绝大部分的员工持股都是亏的怎么办？ 通常的做法都是展期，有一年的，有两年的，反正就一个字，拖。其中有一部分公司在大幅亏损的情况下选择终止员工持股计划，这些公司都有一个共同的特点就是配资部分超过了1:1，这个在资管新规出来以后是不符合规定的，所以必须要卖出。 整个员工持股计划的周期一般在2年左右，也有3年的，加上展期3～5年很常见，试问职业生涯有几个3、5年？ 作为员工如何破局？ 要回归本质，要了解自己公司的前景如何，发展会不会比现在更好，创始人人品如何？投资人或投资团队操作过的案例（对资金流进行溯源）及风评怎样？ 核心思想，要做价值投资，以上只是价值投资的参考因素。 参与公司员工持股计划，实际上是一种以员工身份进行的投资行为。因此，重点在两方面： 其一，你是否愿意将自己与公司绑定一段时间？这个需要认真考虑。 其二，既然是投资行为，成本、收益、风险如何，值得认真衡量。 总结下来就是，公司是否值得你为之奋斗？投资的渠道非常广泛，投资公司是否是你所知道的最佳投资方式？ 同时，还要考虑以下几个问题： 员工持股的实施方式，一定程度决定了参与员工持股计划的成本。员工持股的实施方式通常是员工自己掏钱在二级市场或者通过公司进行非公开发行取得公司股份。不过有的上市公司员工持股的股份由控股的股东直接赠送给员工，显然相对来说后者更有诱惑力。 个人职业发展定位。员工持股计划对股份通常有一定时间的锁定的。比如一到三年。那么这段期间，公司通常不愿意看到员工离职的，如果离职，也往往不能继续持有通过员工持股计划取得的相应股份，可能需要自己在离职前进行转售。如果你有换工作的打算，见鬼去吧。 公司的的行业地位与发展前景。参与员工持股计划最终能否取得收益，完全取决于持股计划到期时公司股票在二级市场的交易价格与最初股票购买价格的差额。因此，而持股计划到期时公司股票的交易价格与公司的行业地位与发展前景具有一定的关联性。 员工持股计划实时性A股大盘行情。A股股市不同年份股指波动较大，如果员工持股计划在牛市时实施，若干年后大盘转熊的概率比较大，这个时候可能员工持股计划获得的收益将及其有限。 持股计划的结构化安排和个人的风险偏好。为了扩大员工在持股计划获得的收益额，可能会对员工持股计划进行结构化的安排，为员工在银行取得一定比例的配资额，进行杆杠化操作。如果进行1：3的杆杠化，如果员工持股计划股票买入价格10元，员工持股计划到期时，股票价格20元，不考虑员工持股计划的管理费用、银行配资的成本，那么员工可以获得4倍的收益（如果没有杆杠化，只能获得1倍的收益）。相反的，如果到时候亏损，同样会扩大个人的亏损额度。因此要进行权衡。如果公司控股股东能够对该亏损进行兜底，则员工个人风险会小很多。 归根结底，要做价值投资。投资需谨慎，谁的钱都不是大风刮来的。","categories":[{"name":"笔记","slug":"笔记","permalink":"http://debug.cool/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"股票","slug":"股票","permalink":"http://debug.cool/tags/%E8%82%A1%E7%A5%A8/"},{"name":"碎碎念","slug":"碎碎念","permalink":"http://debug.cool/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}]},{"title":"利用多核CPU加速Linux命令","slug":"tipsLinuxCommand","date":"2015-08-13T23:22:03.000Z","updated":"2022-11-15T14:37:32.536Z","comments":true,"path":"2015/08/14/tipsLinuxCommand/","link":"","permalink":"http://debug.cool/2015/08/14/tipsLinuxCommand/","excerpt":"要想让Linux命令使用所有的CPU内核，我们需要用到GNU Parallel命令，它让我们所有的CPU内核在单机内做神奇的map-reduce操作，当然，这还要借助很少用到的–pipes 参数(也叫做–spreadstdin)。这样，你的负载就会平均分配到各CPU上。","text":"要想让Linux命令使用所有的CPU内核，我们需要用到GNU Parallel命令，它让我们所有的CPU内核在单机内做神奇的map-reduce操作，当然，这还要借助很少用到的–pipes 参数(也叫做–spreadstdin)。这样，你的负载就会平均分配到各CPU上。 你是否曾经有过要计算一个非常大的数据(几百 GB)的需求？或在里面搜索，或其它操作——一些无法并行的操作。数据专家们，我是在对你们说。你可能有一个 4 核或更多核的 CPU，但我们合适的工具，例如 grep, bzip2, wc, awk, sed等等，都是单线程的，只能使用一个 CPU 内核。 借用卡通人物 Cartman 的话，“如何我能使用这些内核”? 要想让 Linux 命令使用所有的 CPU 内核，我们需要用到GNU Parallel命令，它让我们所有的 CPU 内核在单机内做神奇的 map-reduce 操作，当然，这还要借助很少用到的–pipes 参数(也叫做–spreadstdin)。这样，你的负载就会平均分配到各 CPU 上，真的。 BZIP2 bzip2 是比 gzip 更好的压缩工具，但它很慢！别折腾了，我们有办法解决这问题。 以前的做法： 1cat bigfile.bin | bzip2 –best &gt; compressedfile.bz2 现在这样： 1cat bigfile.bin | parallel –pipe –recend ” -k bzip2 –best &gt; compressedfile.bz2 尤其是针对 bzip2，GNU parallel 在多核 CPU 上是超级的快。你一不留神，它就执行完成了。 GREP 如果你有一个非常大的文本文件，以前你可能会这样： 1grep pattern bigfile.txt 现在你可以这样： 1cat bigfile.txt | parallel –pipe grep ‘pattern’ 或者这样： 1cat bigfile.txt | parallel –block 10M –pipe grep ‘pattern’ 这第二种用法使用了 –block 10M 参数，这是说每个内核处理 1 千万行——你可以用这个参数来调整每个 CUP 内核处理多少行数据。 AWK 下面是一个用 awk 命令计算一个非常大的数据文件的例子。 常规用法： 1cat rands20M.txt | awk ‘&#123;s+=$1&#125; END &#123;print s&#125;’ 现在这样： 1cat rands20M.txt | parallel –pipe awk \\&#x27;&#123;s+=\\$1&#125; END &#123;print s&#125;\\’ | awk ‘&#123;s+=$1&#125; END &#123;print s&#125;’ 这个有点复杂：parallel命令中的–pipe参数将cat输出分成多个块分派给awk调用，形成了很多子计算操作。这些子计算经过第二个管道进入了同一个awk命令，从而输出最终结果。第一个awk有三个反斜杠，这是GNU parallel调用awk的需要。 WC 想要最快的速度计算一个文件的行数吗？ 传统做法： 1wc -l bigfile.txt 现在你应该这样： 1cat bigfile.txt | parallel –pipe wc -l | awk ‘&#123;s+=$1&#125; END &#123;print s&#125;’ 非常的巧妙，先使用parallel命令mapping出大量的wc -l调用，形成子计算，最后通过管道发送给awk进行汇总。 SED 想在一个巨大的文件里使用 sed 命令做大量的替换操作吗？ 常规做法： 1sed s^old^new^g bigfile.txt 现在你可以： 1cat bigfile.txt | parallel –pipe sed s^old^new^g 然后你可以使用管道把输出存储到指定的文件里。","categories":[{"name":"笔记","slug":"笔记","permalink":"http://debug.cool/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"命令行","slug":"命令行","permalink":"http://debug.cool/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"name":"小技巧","slug":"小技巧","permalink":"http://debug.cool/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"}]},{"title":"低成本打造NAS","slug":"diyNAS","date":"2015-07-01T07:44:00.000Z","updated":"2022-11-15T14:34:20.416Z","comments":true,"path":"2015/07/01/diyNAS/","link":"","permalink":"http://debug.cool/2015/07/01/diyNAS/","excerpt":"在CQUPT的日常，除了上课和打比赛，还业余兼职代码搬砖工，靠着卖代码攒了点钱换个好一点的笔记本(游戏本)，以前的那台破笔记本的硬盘怎么处理呢，卖废品？还是买的材料强化+15一下，改装成NAS废物利用吧，刚好各大网盘非会员限速，太难搞了。","text":"在CQUPT的日常，除了上课和打比赛，还业余兼职代码搬砖工，靠着卖代码攒了点钱换个好一点的笔记本(游戏本)，以前的那台破笔记本的硬盘怎么处理呢，卖废品？还是买的材料强化+15一下，改装成NAS废物利用吧，刚好各大网盘非会员限速，太难搞了。 本着能(没)省(钱)就(装)省(逼)的原则，本次DIY黑群的硬件均来自某鱼二手，历经一两个月的采购，终于备齐了黑群所有的硬件。 NAS是什么？ 来自维基百科： 即网络连接存储设备（Network Attached Storage，NAS）是一种专门的数据存储技术的名称，它可以直接连接在电脑网络上面，对不同平台的网络用户提供了集中式数据访问服务。 NAS和传统的文件存储服务或直接存储设备不同的地方，在于NAS设备上面的操作系统和软件只提供了数据存储、数据访问、以及相关的管理功能；此外，NAS设备也提供了不止一种文件传输协议。NAS系统通常有一个以上的硬盘，而且和传统的文件服务器一样，通常会把它们组成RAID来提供服务；有了NAS以后，网络上的其他服务器就可以不必再兼任文件服务器的功能。NAS的型式很多样化，可以是一个大量生产的嵌入式设备，也可以在一般的电脑上运行NAS的软件。 简而言之，就是一台电脑，运行特定的文件管理软件，使之在局域网内甚至互联网中，供指定用户进行文件的访问与存贮，它的特点是：7 * 24 小时运转，静音，且低功耗。 所以，Intel B85，P61，推土机FX等一众高功耗的平台就没考虑了，虽然性能没得说，可是…真的没必要，一个月下来，电费都有得交，不划算。 硬件 主板 技嘉E350 某鱼220到手，估约着8成新吧，包装盒说明书光盘和背板都在。，四个SATA3，AMD E-350 1.6GHz双核，硬解1080P视频完全没问题，一个千兆网口，最大功耗36W，8个USB2.0，2个USB3.0，卖家还送了条4G DDR3 1333金士顿内存。这价格…还要啥自行车？真是好卖家呀，感激ing… 机箱+电源 惠普小机箱+原装电源 （图上主板是卖家的图，实际上只有机箱和原装电源） 机箱+电源，某鱼50块到手，同城自取的。不得不说，惠普原装电源质量还是很不错的，功率220W，也足够NAS用来，虽然不是主动式、不过…没所谓了，加上硬盘，整机功耗估计也超不过50W，这小主机原来是用在惠普台式桌面电脑的，估计也有4-5个年头了吧。 硬盘 硬盘用的是两块东芝3T机械盘，SATA3，7200转/64M，NAS专用盘太贵，凑合着用吧。另外还加了一块16G固态，用作NAS里安装各种套件用，如Docker PhotoStation,VideoStation等等，或许对运行起来有更快一些吧。 组装工作 按照电脑装机的方法装进去就行，没啥好说的，注意理线，做好通风散热。上一张图片看看效果 拍的时候正在安装调试，没有整理，线比较乱，1处是两块3T HDD，2处是一块16G SSD。后面又加了个超频三的散热风扇，因为原装的机箱扇热实在太吵了，某东15.9到手，另外加10M超五类网线18.9。 软件 软件部分主要讲黑群晖的安装（DSM系统的部署），硬盘的添加，DDNS设置，DNSpod相关设置，为NAS添加SSL证书等等。 PS:洗白就算了吧，据我所知一家之言，误，目前群晖官方基本已全线封锁了洗白的途径。老实用黑群也是一样的。用自有域名远程访问速度也很快，还能装X…(笑 注意！注意！注意 实现自有域名远程访问的前提是：拥有公网IP！ 对于这个问题，电信用户就很舒服了，致电客服，跟她要一个公网IP就行，理由就说：家里有小孩，需要安装监控，需要远程办公balabala…一般情况下都会给你开通的，开通之后会有专门的工作人员打电话与你确认，确认之后，拔掉路由器电源，稍等个5分钟再插上，你就是公网IP了。联通部分地区会给，有的地区也是不给的。至于移动宽带用户…别哭了，哭也没用，讲破喉咙客服也不会开的，因为移动网本身就是一个“局域网”，除非花高价钱买一个固定IP…还是去用花生壳或者3322.org，也可以用自有域名+VPS，使用frp或者Ngrok实现内网穿透。也是个方法，只不过实施起来会复杂一些罢了，有空再写一篇这个教程吧 =_= 材料 U盘/SD卡（读卡器） 顶级域名（小众域名也可以） DNSpod 账号 域名对应的SSL证书（TrustAsia TLS RSA CA证书）怎么申请？自行百度。 黑群晖主机 怎么制作？往前查看硬件章节部分 网线、交换机、路由、等其他。 注意！注意！注意！申请SSL证书的前提是，你的顶级域名已经经过ICP备案（当然，用AlphaSSL 野卡也是可以的）~ 步骤 这可能会很长，所以我打算分成四个部分来讲： U盘引导文件制作 DSM系统的部署（黑群晖系统的安装） 自有域名+DNSpod实现远程访问黑群 给你的NAS加个保护伞——远程访问上HTTPS U盘引导文件制作（以安装6.1版本群晖为例） 部署之前，需要说明一下：DSM系统的加载方式；DSM系统采用系统和数据相分离的方式，所以DSM的引导系统需要一个独立的引导设备，可以是U盘、SD卡，或者SSD硬盘。而数据安装在另外的数据盘上，一般是HDD硬盘，当然也可以是大容量SSD，如果你有钱的话… 一般情况下，大都是用U盘或者SD卡，进行引导启动，容量不需要多大，4G绰绰有余，用8G/16G来做就有点浪费了。至于存储用的容量盘，容量越大越好，推荐NAS专用盘，当然，普通台式机硬盘也可以。 所需文件、软件 芯片无忧 OSFMount虚拟光驱软件x64 U盘制作软件Win32_Disk_Imager 镜像文件 synoboot.img 安装文件 DSM_DS3617xs_15101.pat 群晖助手SynologyAssistant.exe 记录U盘 PID/VID参数 打开芯片无忧软件，记录U盘PID/VID 如上图，我的闪迪U盘的VID=13FE,PID=5500，每个设备都是不一样的，切勿按照我的填写。 修改Img 镜像文件（引导文件） 安装并打开osfmount软件，加载镜像文件 选择第二项Partition 0 —— OK 取消勾选 Read Only-drive —— OK 双击打开该镜像文件——打开grub文件夹——选择 grub.cfg——右键使用文本编辑工具打开（NotePad++/Subline） 将图上VID/PID参数改为自己U盘对应的参数。比如我的VID=0x13FE、PID=0x5500 注：图上SN码，和MAC地址需要特殊算号器和宏文件算出，目前所有的在线算号器均已失效，按照某论坛大神的说法，现在洗白需要有一台白群晖来做引导，涉及群晖洗白问题，这里不做过多赘述，其实不洗白也是一样的，别用那个Quickconnect服务就是了，非要洗白，请自行搜索相关教程。 最后保存更改之后的镜像引导文件； 引导文件写入U盘 下载并安装Win32DiskImager，插上U盘，打开该软件，选择刚才修改过的Img镜像文件 注意：用该软件制作启动盘，会将U盘格式化，并且windows平台无法读取，因为是Linux格式，请先备份资料。 大约1分钟就能制作完成 制作好了时候，插入黑群晖主机 安装群晖之前，先在内网一台PC上安装群晖助手 Synology Assistant（注：黑群和PC连接同一个交换机/路由，建议还是一同直连路由器） 安装好了之后，再进入黑群主板BIOS，设置为U盘启动，不同主板设置方式不一样，请自行搜索相关设置方法。 注意：群晖DSM6.x 系统之后，要求主板必须支持UEFI 方式启动，所以…老主板还是建议安装5.2系统~ 设置好了时候，检查一下线路，确保网线，交换机，路由器，都能正常连接，且能连接互联网（误），黑群晖主机接上显示器，和键鼠 DSM 系统的安装 插入制作好的U盘，开机…选择第二项…回车 然后开始进入引导，会显示一连串的[OK]，出现下列画面说明引导成功 接着打开局域网内PC上的群晖助手，点击“搜索”，就能找到刚刚安装的群晖 右键“安装” 选择下载的 .pat安装文件 设置管理员和网络（注意：网关地址一定要与路由器上的网关一致，否则局域网内将无法找到群晖！） 设置完了就开始安装了，大概十几分钟吧，我的用了将近18分钟才装完，可能是APU太渣吧 安装完成~ 取消自动更新，或者设置为“不自动安装更新，有更新时提醒我” 最后~设置初始化硬盘，根据自己需要设置RAID ，这一步会很久很久，我的两个3T HDD + 16G SSD,用了10个小时…让它默默的校验去吧，可别断电噢。。。 至此，黑群晖安装大功告成！ 总结 这一套算下来，主板+内存 ￥220，机箱+电源 ￥50，风扇￥15.9，10m超五类网线￥18.9，合计￥304.8。这价格能攒个4盘位NAS黑裙，反正我是知足了","categories":[{"name":"笔记","slug":"笔记","permalink":"http://debug.cool/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://debug.cool/tags/%E7%AC%94%E8%AE%B0/"},{"name":"NAS","slug":"NAS","permalink":"http://debug.cool/tags/NAS/"},{"name":"DIY","slug":"DIY","permalink":"http://debug.cool/tags/DIY/"},{"name":"家庭NAS","slug":"家庭NAS","permalink":"http://debug.cool/tags/%E5%AE%B6%E5%BA%ADNAS/"}]}],"categories":[{"name":"笔记","slug":"笔记","permalink":"http://debug.cool/categories/%E7%AC%94%E8%AE%B0/"},{"name":"安全","slug":"安全","permalink":"http://debug.cool/categories/%E5%AE%89%E5%85%A8/"},{"name":"研发","slug":"研发","permalink":"http://debug.cool/categories/%E7%A0%94%E5%8F%91/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://debug.cool/tags/%E7%AE%97%E6%B3%95/"},{"name":"读后感","slug":"读后感","permalink":"http://debug.cool/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"},{"name":"Future Politics","slug":"Future-Politics","permalink":"http://debug.cool/tags/Future-Politics/"},{"name":"网络安全","slug":"网络安全","permalink":"http://debug.cool/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"碎碎念","slug":"碎碎念","permalink":"http://debug.cool/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"},{"name":"Python","slug":"Python","permalink":"http://debug.cool/tags/Python/"},{"name":"WSL","slug":"WSL","permalink":"http://debug.cool/tags/WSL/"},{"name":"Windows10","slug":"Windows10","permalink":"http://debug.cool/tags/Windows10/"},{"name":"Nginx","slug":"Nginx","permalink":"http://debug.cool/tags/Nginx/"},{"name":"PHP","slug":"PHP","permalink":"http://debug.cool/tags/PHP/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://debug.cool/tags/Ubuntu/"},{"name":"研发","slug":"研发","permalink":"http://debug.cool/tags/%E7%A0%94%E5%8F%91/"},{"name":"自定义表达式","slug":"自定义表达式","permalink":"http://debug.cool/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"状态机","slug":"状态机","permalink":"http://debug.cool/tags/%E7%8A%B6%E6%80%81%E6%9C%BA/"},{"name":"自然语言解析","slug":"自然语言解析","permalink":"http://debug.cool/tags/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E8%A7%A3%E6%9E%90/"},{"name":"笔记","slug":"笔记","permalink":"http://debug.cool/tags/%E7%AC%94%E8%AE%B0/"},{"name":"维修","slug":"维修","permalink":"http://debug.cool/tags/%E7%BB%B4%E4%BF%AE/"},{"name":"自定义模版","slug":"自定义模版","permalink":"http://debug.cool/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E7%89%88/"},{"name":"数据存储","slug":"数据存储","permalink":"http://debug.cool/tags/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"},{"name":"数仓","slug":"数仓","permalink":"http://debug.cool/tags/%E6%95%B0%E4%BB%93/"},{"name":"数据湖","slug":"数据湖","permalink":"http://debug.cool/tags/%E6%95%B0%E6%8D%AE%E6%B9%96/"},{"name":"破解","slug":"破解","permalink":"http://debug.cool/tags/%E7%A0%B4%E8%A7%A3/"},{"name":"Kafka","slug":"Kafka","permalink":"http://debug.cool/tags/Kafka/"},{"name":"任务分配","slug":"任务分配","permalink":"http://debug.cool/tags/%E4%BB%BB%E5%8A%A1%E5%88%86%E9%85%8D/"},{"name":"Matplotlib","slug":"Matplotlib","permalink":"http://debug.cool/tags/Matplotlib/"},{"name":"逆向","slug":"逆向","permalink":"http://debug.cool/tags/%E9%80%86%E5%90%91/"},{"name":"汇编","slug":"汇编","permalink":"http://debug.cool/tags/%E6%B1%87%E7%BC%96/"},{"name":"内核","slug":"内核","permalink":"http://debug.cool/tags/%E5%86%85%E6%A0%B8/"},{"name":"股票","slug":"股票","permalink":"http://debug.cool/tags/%E8%82%A1%E7%A5%A8/"},{"name":"命令行","slug":"命令行","permalink":"http://debug.cool/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"name":"小技巧","slug":"小技巧","permalink":"http://debug.cool/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"name":"NAS","slug":"NAS","permalink":"http://debug.cool/tags/NAS/"},{"name":"DIY","slug":"DIY","permalink":"http://debug.cool/tags/DIY/"},{"name":"家庭NAS","slug":"家庭NAS","permalink":"http://debug.cool/tags/%E5%AE%B6%E5%BA%ADNAS/"}]}